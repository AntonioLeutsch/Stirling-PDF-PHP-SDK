<?php
/**
 * SecurityApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Stirling PDF - Processing API
 *
 * API documentation for PDF processing operations including conversion, manipulation, security, and utilities. Please note all requests require authentication and as such should have a 'X-API-KEY' provided in their header
 *
 * The version of the OpenAPI document: 1.0.1
 * Contact: contact@stirlingpdf.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.19.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * SecurityApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class SecurityApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'addPassword' => [
            'multipart/form-data',
        ],
        'addWatermark' => [
            'multipart/form-data',
        ],
        'getPdfInfo' => [
            'multipart/form-data',
        ],
        'redactPdfAuto' => [
            'multipart/form-data',
        ],
        'redactPdfManual' => [
            'multipart/form-data',
        ],
        'removeCertSignPDF' => [
            'multipart/form-data',
        ],
        'removePassword' => [
            'multipart/form-data',
        ],
        'sanitizePDF' => [
            'multipart/form-data',
        ],
        'signPDFWithCert' => [
            'multipart/form-data',
        ],
        'validateSignature' => [
            'multipart/form-data',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addPassword
     *
     * Add password to a PDF file
     *
     * @param  int $key_length The length of the encryption key (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $owner_password The owner password to be added to the PDF file (Restricts what can be done with the document once it is opened) (optional)
     * @param  string|null $password The password to be added to the PDF file (Restricts the opening of the document itself.) (optional)
     * @param  bool|null $prevent_assembly Whether document assembly is prevented (optional, default to false)
     * @param  bool|null $prevent_extract_content Whether content extraction is prevented (optional, default to false)
     * @param  bool|null $prevent_extract_for_accessibility Whether content extraction for accessibility is prevented (optional, default to false)
     * @param  bool|null $prevent_fill_in_form Whether form filling is prevented (optional, default to false)
     * @param  bool|null $prevent_modify Whether document modification is prevented (optional, default to false)
     * @param  bool|null $prevent_modify_annotations Whether modification of annotations is prevented (optional, default to false)
     * @param  bool|null $prevent_printing Whether printing of the document is prevented (optional, default to false)
     * @param  bool|null $prevent_printing_faithful Whether faithful printing is prevented (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addPassword'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function addPassword($key_length, $file_input = null, $file_id = null, $owner_password = null, $password = null, $prevent_assembly = false, $prevent_extract_content = false, $prevent_extract_for_accessibility = false, $prevent_fill_in_form = false, $prevent_modify = false, $prevent_modify_annotations = false, $prevent_printing = false, $prevent_printing_faithful = false, string $contentType = self::contentTypes['addPassword'][0])
    {
        list($response) = $this->addPasswordWithHttpInfo($key_length, $file_input, $file_id, $owner_password, $password, $prevent_assembly, $prevent_extract_content, $prevent_extract_for_accessibility, $prevent_fill_in_form, $prevent_modify, $prevent_modify_annotations, $prevent_printing, $prevent_printing_faithful, $contentType);
        return $response;
    }

    /**
     * Operation addPasswordWithHttpInfo
     *
     * Add password to a PDF file
     *
     * @param  int $key_length The length of the encryption key (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $owner_password The owner password to be added to the PDF file (Restricts what can be done with the document once it is opened) (optional)
     * @param  string|null $password The password to be added to the PDF file (Restricts the opening of the document itself.) (optional)
     * @param  bool|null $prevent_assembly Whether document assembly is prevented (optional, default to false)
     * @param  bool|null $prevent_extract_content Whether content extraction is prevented (optional, default to false)
     * @param  bool|null $prevent_extract_for_accessibility Whether content extraction for accessibility is prevented (optional, default to false)
     * @param  bool|null $prevent_fill_in_form Whether form filling is prevented (optional, default to false)
     * @param  bool|null $prevent_modify Whether document modification is prevented (optional, default to false)
     * @param  bool|null $prevent_modify_annotations Whether modification of annotations is prevented (optional, default to false)
     * @param  bool|null $prevent_printing Whether printing of the document is prevented (optional, default to false)
     * @param  bool|null $prevent_printing_faithful Whether faithful printing is prevented (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addPassword'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function addPasswordWithHttpInfo($key_length, $file_input = null, $file_id = null, $owner_password = null, $password = null, $prevent_assembly = false, $prevent_extract_content = false, $prevent_extract_for_accessibility = false, $prevent_fill_in_form = false, $prevent_modify = false, $prevent_modify_annotations = false, $prevent_printing = false, $prevent_printing_faithful = false, string $contentType = self::contentTypes['addPassword'][0])
    {
        $request = $this->addPasswordRequest($key_length, $file_input, $file_id, $owner_password, $password, $prevent_assembly, $prevent_extract_content, $prevent_extract_for_accessibility, $prevent_fill_in_form, $prevent_modify, $prevent_modify_annotations, $prevent_printing, $prevent_printing_faithful, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation addPasswordAsync
     *
     * Add password to a PDF file
     *
     * @param  int $key_length The length of the encryption key (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $owner_password The owner password to be added to the PDF file (Restricts what can be done with the document once it is opened) (optional)
     * @param  string|null $password The password to be added to the PDF file (Restricts the opening of the document itself.) (optional)
     * @param  bool|null $prevent_assembly Whether document assembly is prevented (optional, default to false)
     * @param  bool|null $prevent_extract_content Whether content extraction is prevented (optional, default to false)
     * @param  bool|null $prevent_extract_for_accessibility Whether content extraction for accessibility is prevented (optional, default to false)
     * @param  bool|null $prevent_fill_in_form Whether form filling is prevented (optional, default to false)
     * @param  bool|null $prevent_modify Whether document modification is prevented (optional, default to false)
     * @param  bool|null $prevent_modify_annotations Whether modification of annotations is prevented (optional, default to false)
     * @param  bool|null $prevent_printing Whether printing of the document is prevented (optional, default to false)
     * @param  bool|null $prevent_printing_faithful Whether faithful printing is prevented (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addPassword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addPasswordAsync($key_length, $file_input = null, $file_id = null, $owner_password = null, $password = null, $prevent_assembly = false, $prevent_extract_content = false, $prevent_extract_for_accessibility = false, $prevent_fill_in_form = false, $prevent_modify = false, $prevent_modify_annotations = false, $prevent_printing = false, $prevent_printing_faithful = false, string $contentType = self::contentTypes['addPassword'][0])
    {
        return $this->addPasswordAsyncWithHttpInfo($key_length, $file_input, $file_id, $owner_password, $password, $prevent_assembly, $prevent_extract_content, $prevent_extract_for_accessibility, $prevent_fill_in_form, $prevent_modify, $prevent_modify_annotations, $prevent_printing, $prevent_printing_faithful, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addPasswordAsyncWithHttpInfo
     *
     * Add password to a PDF file
     *
     * @param  int $key_length The length of the encryption key (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $owner_password The owner password to be added to the PDF file (Restricts what can be done with the document once it is opened) (optional)
     * @param  string|null $password The password to be added to the PDF file (Restricts the opening of the document itself.) (optional)
     * @param  bool|null $prevent_assembly Whether document assembly is prevented (optional, default to false)
     * @param  bool|null $prevent_extract_content Whether content extraction is prevented (optional, default to false)
     * @param  bool|null $prevent_extract_for_accessibility Whether content extraction for accessibility is prevented (optional, default to false)
     * @param  bool|null $prevent_fill_in_form Whether form filling is prevented (optional, default to false)
     * @param  bool|null $prevent_modify Whether document modification is prevented (optional, default to false)
     * @param  bool|null $prevent_modify_annotations Whether modification of annotations is prevented (optional, default to false)
     * @param  bool|null $prevent_printing Whether printing of the document is prevented (optional, default to false)
     * @param  bool|null $prevent_printing_faithful Whether faithful printing is prevented (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addPassword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addPasswordAsyncWithHttpInfo($key_length, $file_input = null, $file_id = null, $owner_password = null, $password = null, $prevent_assembly = false, $prevent_extract_content = false, $prevent_extract_for_accessibility = false, $prevent_fill_in_form = false, $prevent_modify = false, $prevent_modify_annotations = false, $prevent_printing = false, $prevent_printing_faithful = false, string $contentType = self::contentTypes['addPassword'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->addPasswordRequest($key_length, $file_input, $file_id, $owner_password, $password, $prevent_assembly, $prevent_extract_content, $prevent_extract_for_accessibility, $prevent_fill_in_form, $prevent_modify, $prevent_modify_annotations, $prevent_printing, $prevent_printing_faithful, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addPassword'
     *
     * @param  int $key_length The length of the encryption key (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $owner_password The owner password to be added to the PDF file (Restricts what can be done with the document once it is opened) (optional)
     * @param  string|null $password The password to be added to the PDF file (Restricts the opening of the document itself.) (optional)
     * @param  bool|null $prevent_assembly Whether document assembly is prevented (optional, default to false)
     * @param  bool|null $prevent_extract_content Whether content extraction is prevented (optional, default to false)
     * @param  bool|null $prevent_extract_for_accessibility Whether content extraction for accessibility is prevented (optional, default to false)
     * @param  bool|null $prevent_fill_in_form Whether form filling is prevented (optional, default to false)
     * @param  bool|null $prevent_modify Whether document modification is prevented (optional, default to false)
     * @param  bool|null $prevent_modify_annotations Whether modification of annotations is prevented (optional, default to false)
     * @param  bool|null $prevent_printing Whether printing of the document is prevented (optional, default to false)
     * @param  bool|null $prevent_printing_faithful Whether faithful printing is prevented (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addPassword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addPasswordRequest($key_length, $file_input = null, $file_id = null, $owner_password = null, $password = null, $prevent_assembly = false, $prevent_extract_content = false, $prevent_extract_for_accessibility = false, $prevent_fill_in_form = false, $prevent_modify = false, $prevent_modify_annotations = false, $prevent_printing = false, $prevent_printing_faithful = false, string $contentType = self::contentTypes['addPassword'][0])
    {

        // verify the required parameter 'key_length' is set
        if ($key_length === null || (is_array($key_length) && count($key_length) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key_length when calling addPassword'
            );
        }














        $resourcePath = '/api/v1/security/add-password';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'owner_password' => $owner_password,
            'password' => $password,
            'key_length' => $key_length,
            'prevent_assembly' => $prevent_assembly,
            'prevent_extract_content' => $prevent_extract_content,
            'prevent_extract_for_accessibility' => $prevent_extract_for_accessibility,
            'prevent_fill_in_form' => $prevent_fill_in_form,
            'prevent_modify' => $prevent_modify,
            'prevent_modify_annotations' => $prevent_modify_annotations,
            'prevent_printing' => $prevent_printing,
            'prevent_printing_faithful' => $prevent_printing_faithful,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addWatermark
     *
     * Add watermark to a PDF file
     *
     * @param  string $watermark_type The watermark type (text or image) (required)
     * @param  bool $convert_pdfto_image Convert the redacted PDF to an image (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $watermark_text The watermark text (optional, default to 'Stirling Software')
     * @param  \SplFileObject|null $watermark_image watermark_image (optional)
     * @param  string|null $alphabet The selected alphabet (optional, default to 'roman')
     * @param  float|null $font_size The font size of the watermark text (optional, default to 30)
     * @param  float|null $rotation The rotation of the watermark in degrees (optional, default to 0)
     * @param  float|null $opacity The opacity of the watermark (0.0 - 1.0) (optional, default to 0.5)
     * @param  int|null $width_spacer The width spacer between watermark elements (optional, default to 50)
     * @param  int|null $height_spacer The height spacer between watermark elements (optional, default to 50)
     * @param  string|null $custom_color The color for watermark (optional, default to '#d3d3d3')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addWatermark'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function addWatermark($watermark_type, $convert_pdfto_image, $file_input = null, $file_id = null, $watermark_text = 'Stirling Software', $watermark_image = null, $alphabet = 'roman', $font_size = 30, $rotation = 0, $opacity = 0.5, $width_spacer = 50, $height_spacer = 50, $custom_color = '#d3d3d3', string $contentType = self::contentTypes['addWatermark'][0])
    {
        list($response) = $this->addWatermarkWithHttpInfo($watermark_type, $convert_pdfto_image, $file_input, $file_id, $watermark_text, $watermark_image, $alphabet, $font_size, $rotation, $opacity, $width_spacer, $height_spacer, $custom_color, $contentType);
        return $response;
    }

    /**
     * Operation addWatermarkWithHttpInfo
     *
     * Add watermark to a PDF file
     *
     * @param  string $watermark_type The watermark type (text or image) (required)
     * @param  bool $convert_pdfto_image Convert the redacted PDF to an image (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $watermark_text The watermark text (optional, default to 'Stirling Software')
     * @param  \SplFileObject|null $watermark_image (optional)
     * @param  string|null $alphabet The selected alphabet (optional, default to 'roman')
     * @param  float|null $font_size The font size of the watermark text (optional, default to 30)
     * @param  float|null $rotation The rotation of the watermark in degrees (optional, default to 0)
     * @param  float|null $opacity The opacity of the watermark (0.0 - 1.0) (optional, default to 0.5)
     * @param  int|null $width_spacer The width spacer between watermark elements (optional, default to 50)
     * @param  int|null $height_spacer The height spacer between watermark elements (optional, default to 50)
     * @param  string|null $custom_color The color for watermark (optional, default to '#d3d3d3')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addWatermark'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function addWatermarkWithHttpInfo($watermark_type, $convert_pdfto_image, $file_input = null, $file_id = null, $watermark_text = 'Stirling Software', $watermark_image = null, $alphabet = 'roman', $font_size = 30, $rotation = 0, $opacity = 0.5, $width_spacer = 50, $height_spacer = 50, $custom_color = '#d3d3d3', string $contentType = self::contentTypes['addWatermark'][0])
    {
        $request = $this->addWatermarkRequest($watermark_type, $convert_pdfto_image, $file_input, $file_id, $watermark_text, $watermark_image, $alphabet, $font_size, $rotation, $opacity, $width_spacer, $height_spacer, $custom_color, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation addWatermarkAsync
     *
     * Add watermark to a PDF file
     *
     * @param  string $watermark_type The watermark type (text or image) (required)
     * @param  bool $convert_pdfto_image Convert the redacted PDF to an image (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $watermark_text The watermark text (optional, default to 'Stirling Software')
     * @param  \SplFileObject|null $watermark_image (optional)
     * @param  string|null $alphabet The selected alphabet (optional, default to 'roman')
     * @param  float|null $font_size The font size of the watermark text (optional, default to 30)
     * @param  float|null $rotation The rotation of the watermark in degrees (optional, default to 0)
     * @param  float|null $opacity The opacity of the watermark (0.0 - 1.0) (optional, default to 0.5)
     * @param  int|null $width_spacer The width spacer between watermark elements (optional, default to 50)
     * @param  int|null $height_spacer The height spacer between watermark elements (optional, default to 50)
     * @param  string|null $custom_color The color for watermark (optional, default to '#d3d3d3')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addWatermark'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addWatermarkAsync($watermark_type, $convert_pdfto_image, $file_input = null, $file_id = null, $watermark_text = 'Stirling Software', $watermark_image = null, $alphabet = 'roman', $font_size = 30, $rotation = 0, $opacity = 0.5, $width_spacer = 50, $height_spacer = 50, $custom_color = '#d3d3d3', string $contentType = self::contentTypes['addWatermark'][0])
    {
        return $this->addWatermarkAsyncWithHttpInfo($watermark_type, $convert_pdfto_image, $file_input, $file_id, $watermark_text, $watermark_image, $alphabet, $font_size, $rotation, $opacity, $width_spacer, $height_spacer, $custom_color, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addWatermarkAsyncWithHttpInfo
     *
     * Add watermark to a PDF file
     *
     * @param  string $watermark_type The watermark type (text or image) (required)
     * @param  bool $convert_pdfto_image Convert the redacted PDF to an image (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $watermark_text The watermark text (optional, default to 'Stirling Software')
     * @param  \SplFileObject|null $watermark_image (optional)
     * @param  string|null $alphabet The selected alphabet (optional, default to 'roman')
     * @param  float|null $font_size The font size of the watermark text (optional, default to 30)
     * @param  float|null $rotation The rotation of the watermark in degrees (optional, default to 0)
     * @param  float|null $opacity The opacity of the watermark (0.0 - 1.0) (optional, default to 0.5)
     * @param  int|null $width_spacer The width spacer between watermark elements (optional, default to 50)
     * @param  int|null $height_spacer The height spacer between watermark elements (optional, default to 50)
     * @param  string|null $custom_color The color for watermark (optional, default to '#d3d3d3')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addWatermark'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addWatermarkAsyncWithHttpInfo($watermark_type, $convert_pdfto_image, $file_input = null, $file_id = null, $watermark_text = 'Stirling Software', $watermark_image = null, $alphabet = 'roman', $font_size = 30, $rotation = 0, $opacity = 0.5, $width_spacer = 50, $height_spacer = 50, $custom_color = '#d3d3d3', string $contentType = self::contentTypes['addWatermark'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->addWatermarkRequest($watermark_type, $convert_pdfto_image, $file_input, $file_id, $watermark_text, $watermark_image, $alphabet, $font_size, $rotation, $opacity, $width_spacer, $height_spacer, $custom_color, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addWatermark'
     *
     * @param  string $watermark_type The watermark type (text or image) (required)
     * @param  bool $convert_pdfto_image Convert the redacted PDF to an image (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $watermark_text The watermark text (optional, default to 'Stirling Software')
     * @param  \SplFileObject|null $watermark_image (optional)
     * @param  string|null $alphabet The selected alphabet (optional, default to 'roman')
     * @param  float|null $font_size The font size of the watermark text (optional, default to 30)
     * @param  float|null $rotation The rotation of the watermark in degrees (optional, default to 0)
     * @param  float|null $opacity The opacity of the watermark (0.0 - 1.0) (optional, default to 0.5)
     * @param  int|null $width_spacer The width spacer between watermark elements (optional, default to 50)
     * @param  int|null $height_spacer The height spacer between watermark elements (optional, default to 50)
     * @param  string|null $custom_color The color for watermark (optional, default to '#d3d3d3')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addWatermark'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addWatermarkRequest($watermark_type, $convert_pdfto_image, $file_input = null, $file_id = null, $watermark_text = 'Stirling Software', $watermark_image = null, $alphabet = 'roman', $font_size = 30, $rotation = 0, $opacity = 0.5, $width_spacer = 50, $height_spacer = 50, $custom_color = '#d3d3d3', string $contentType = self::contentTypes['addWatermark'][0])
    {

        // verify the required parameter 'watermark_type' is set
        if ($watermark_type === null || (is_array($watermark_type) && count($watermark_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $watermark_type when calling addWatermark'
            );
        }

        // verify the required parameter 'convert_pdfto_image' is set
        if ($convert_pdfto_image === null || (is_array($convert_pdfto_image) && count($convert_pdfto_image) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $convert_pdfto_image when calling addWatermark'
            );
        }













        $resourcePath = '/api/v1/security/add-watermark';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'watermark_type' => $watermark_type,
            'watermark_text' => $watermark_text,
            'watermark_image' => $watermark_image,
            'alphabet' => $alphabet,
            'font_size' => $font_size,
            'rotation' => $rotation,
            'opacity' => $opacity,
            'width_spacer' => $width_spacer,
            'height_spacer' => $height_spacer,
            'custom_color' => $custom_color,
            'convert_pdfto_image' => $convert_pdfto_image,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPdfInfo
     *
     * Summary here
     *
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPdfInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function getPdfInfo($file_input = null, $file_id = null, string $contentType = self::contentTypes['getPdfInfo'][0])
    {
        list($response) = $this->getPdfInfoWithHttpInfo($file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation getPdfInfoWithHttpInfo
     *
     * Summary here
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPdfInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPdfInfoWithHttpInfo($file_input = null, $file_id = null, string $contentType = self::contentTypes['getPdfInfo'][0])
    {
        $request = $this->getPdfInfoRequest($file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'object',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPdfInfoAsync
     *
     * Summary here
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPdfInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInfoAsync($file_input = null, $file_id = null, string $contentType = self::contentTypes['getPdfInfo'][0])
    {
        return $this->getPdfInfoAsyncWithHttpInfo($file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPdfInfoAsyncWithHttpInfo
     *
     * Summary here
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPdfInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPdfInfoAsyncWithHttpInfo($file_input = null, $file_id = null, string $contentType = self::contentTypes['getPdfInfo'][0])
    {
        $returnType = 'object';
        $request = $this->getPdfInfoRequest($file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPdfInfo'
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPdfInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPdfInfoRequest($file_input = null, $file_id = null, string $contentType = self::contentTypes['getPdfInfo'][0])
    {




        $resourcePath = '/api/v1/security/get-info-on-pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation redactPdfAuto
     *
     * Redacts listOfText in a PDF document
     *
     * @param  string $list_of_text List of text to redact from the PDF (required)
     * @param  bool $use_regex Whether to use regex for the listOfText (required)
     * @param  bool $whole_word_search Whether to use whole word search (required)
     * @param  string $redact_color The color for redaction (required)
     * @param  float $custom_padding Custom padding for redaction (required)
     * @param  bool $convert_pdfto_image Convert the redacted PDF to an image (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redactPdfAuto'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function redactPdfAuto($list_of_text, $use_regex, $whole_word_search, $redact_color, $custom_padding, $convert_pdfto_image, $file_input = null, $file_id = null, string $contentType = self::contentTypes['redactPdfAuto'][0])
    {
        list($response) = $this->redactPdfAutoWithHttpInfo($list_of_text, $use_regex, $whole_word_search, $redact_color, $custom_padding, $convert_pdfto_image, $file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation redactPdfAutoWithHttpInfo
     *
     * Redacts listOfText in a PDF document
     *
     * @param  string $list_of_text List of text to redact from the PDF (required)
     * @param  bool $use_regex Whether to use regex for the listOfText (required)
     * @param  bool $whole_word_search Whether to use whole word search (required)
     * @param  string $redact_color The color for redaction (required)
     * @param  float $custom_padding Custom padding for redaction (required)
     * @param  bool $convert_pdfto_image Convert the redacted PDF to an image (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redactPdfAuto'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function redactPdfAutoWithHttpInfo($list_of_text, $use_regex, $whole_word_search, $redact_color, $custom_padding, $convert_pdfto_image, $file_input = null, $file_id = null, string $contentType = self::contentTypes['redactPdfAuto'][0])
    {
        $request = $this->redactPdfAutoRequest($list_of_text, $use_regex, $whole_word_search, $redact_color, $custom_padding, $convert_pdfto_image, $file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation redactPdfAutoAsync
     *
     * Redacts listOfText in a PDF document
     *
     * @param  string $list_of_text List of text to redact from the PDF (required)
     * @param  bool $use_regex Whether to use regex for the listOfText (required)
     * @param  bool $whole_word_search Whether to use whole word search (required)
     * @param  string $redact_color The color for redaction (required)
     * @param  float $custom_padding Custom padding for redaction (required)
     * @param  bool $convert_pdfto_image Convert the redacted PDF to an image (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redactPdfAuto'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redactPdfAutoAsync($list_of_text, $use_regex, $whole_word_search, $redact_color, $custom_padding, $convert_pdfto_image, $file_input = null, $file_id = null, string $contentType = self::contentTypes['redactPdfAuto'][0])
    {
        return $this->redactPdfAutoAsyncWithHttpInfo($list_of_text, $use_regex, $whole_word_search, $redact_color, $custom_padding, $convert_pdfto_image, $file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation redactPdfAutoAsyncWithHttpInfo
     *
     * Redacts listOfText in a PDF document
     *
     * @param  string $list_of_text List of text to redact from the PDF (required)
     * @param  bool $use_regex Whether to use regex for the listOfText (required)
     * @param  bool $whole_word_search Whether to use whole word search (required)
     * @param  string $redact_color The color for redaction (required)
     * @param  float $custom_padding Custom padding for redaction (required)
     * @param  bool $convert_pdfto_image Convert the redacted PDF to an image (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redactPdfAuto'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redactPdfAutoAsyncWithHttpInfo($list_of_text, $use_regex, $whole_word_search, $redact_color, $custom_padding, $convert_pdfto_image, $file_input = null, $file_id = null, string $contentType = self::contentTypes['redactPdfAuto'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->redactPdfAutoRequest($list_of_text, $use_regex, $whole_word_search, $redact_color, $custom_padding, $convert_pdfto_image, $file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'redactPdfAuto'
     *
     * @param  string $list_of_text List of text to redact from the PDF (required)
     * @param  bool $use_regex Whether to use regex for the listOfText (required)
     * @param  bool $whole_word_search Whether to use whole word search (required)
     * @param  string $redact_color The color for redaction (required)
     * @param  float $custom_padding Custom padding for redaction (required)
     * @param  bool $convert_pdfto_image Convert the redacted PDF to an image (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redactPdfAuto'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function redactPdfAutoRequest($list_of_text, $use_regex, $whole_word_search, $redact_color, $custom_padding, $convert_pdfto_image, $file_input = null, $file_id = null, string $contentType = self::contentTypes['redactPdfAuto'][0])
    {

        // verify the required parameter 'list_of_text' is set
        if ($list_of_text === null || (is_array($list_of_text) && count($list_of_text) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $list_of_text when calling redactPdfAuto'
            );
        }

        // verify the required parameter 'use_regex' is set
        if ($use_regex === null || (is_array($use_regex) && count($use_regex) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $use_regex when calling redactPdfAuto'
            );
        }

        // verify the required parameter 'whole_word_search' is set
        if ($whole_word_search === null || (is_array($whole_word_search) && count($whole_word_search) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $whole_word_search when calling redactPdfAuto'
            );
        }

        // verify the required parameter 'redact_color' is set
        if ($redact_color === null || (is_array($redact_color) && count($redact_color) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $redact_color when calling redactPdfAuto'
            );
        }

        // verify the required parameter 'custom_padding' is set
        if ($custom_padding === null || (is_array($custom_padding) && count($custom_padding) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_padding when calling redactPdfAuto'
            );
        }

        // verify the required parameter 'convert_pdfto_image' is set
        if ($convert_pdfto_image === null || (is_array($convert_pdfto_image) && count($convert_pdfto_image) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $convert_pdfto_image when calling redactPdfAuto'
            );
        }




        $resourcePath = '/api/v1/security/auto-redact';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'list_of_text' => $list_of_text,
            'use_regex' => $use_regex,
            'whole_word_search' => $whole_word_search,
            'redact_color' => $redact_color,
            'custom_padding' => $custom_padding,
            'convert_pdfto_image' => $convert_pdfto_image,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation redactPdfManual
     *
     * Redacts areas and pages in a PDF document
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  \OpenAPI\Client\Model\RedactionArea[] $redactions A list of areas that should be redacted (required)
     * @param  bool $convert_pdfto_image Convert the redacted PDF to an image (required)
     * @param  string $page_redaction_color The color used to fully redact certain pages (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redactPdfManual'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function redactPdfManual($page_numbers, $redactions, $convert_pdfto_image, $page_redaction_color, $file_input = null, $file_id = null, string $contentType = self::contentTypes['redactPdfManual'][0])
    {
        list($response) = $this->redactPdfManualWithHttpInfo($page_numbers, $redactions, $convert_pdfto_image, $page_redaction_color, $file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation redactPdfManualWithHttpInfo
     *
     * Redacts areas and pages in a PDF document
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  \OpenAPI\Client\Model\RedactionArea[] $redactions A list of areas that should be redacted (required)
     * @param  bool $convert_pdfto_image Convert the redacted PDF to an image (required)
     * @param  string $page_redaction_color The color used to fully redact certain pages (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redactPdfManual'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function redactPdfManualWithHttpInfo($page_numbers, $redactions, $convert_pdfto_image, $page_redaction_color, $file_input = null, $file_id = null, string $contentType = self::contentTypes['redactPdfManual'][0])
    {
        $request = $this->redactPdfManualRequest($page_numbers, $redactions, $convert_pdfto_image, $page_redaction_color, $file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation redactPdfManualAsync
     *
     * Redacts areas and pages in a PDF document
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  \OpenAPI\Client\Model\RedactionArea[] $redactions A list of areas that should be redacted (required)
     * @param  bool $convert_pdfto_image Convert the redacted PDF to an image (required)
     * @param  string $page_redaction_color The color used to fully redact certain pages (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redactPdfManual'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redactPdfManualAsync($page_numbers, $redactions, $convert_pdfto_image, $page_redaction_color, $file_input = null, $file_id = null, string $contentType = self::contentTypes['redactPdfManual'][0])
    {
        return $this->redactPdfManualAsyncWithHttpInfo($page_numbers, $redactions, $convert_pdfto_image, $page_redaction_color, $file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation redactPdfManualAsyncWithHttpInfo
     *
     * Redacts areas and pages in a PDF document
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  \OpenAPI\Client\Model\RedactionArea[] $redactions A list of areas that should be redacted (required)
     * @param  bool $convert_pdfto_image Convert the redacted PDF to an image (required)
     * @param  string $page_redaction_color The color used to fully redact certain pages (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redactPdfManual'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redactPdfManualAsyncWithHttpInfo($page_numbers, $redactions, $convert_pdfto_image, $page_redaction_color, $file_input = null, $file_id = null, string $contentType = self::contentTypes['redactPdfManual'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->redactPdfManualRequest($page_numbers, $redactions, $convert_pdfto_image, $page_redaction_color, $file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'redactPdfManual'
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  \OpenAPI\Client\Model\RedactionArea[] $redactions A list of areas that should be redacted (required)
     * @param  bool $convert_pdfto_image Convert the redacted PDF to an image (required)
     * @param  string $page_redaction_color The color used to fully redact certain pages (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redactPdfManual'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function redactPdfManualRequest($page_numbers, $redactions, $convert_pdfto_image, $page_redaction_color, $file_input = null, $file_id = null, string $contentType = self::contentTypes['redactPdfManual'][0])
    {

        // verify the required parameter 'page_numbers' is set
        if ($page_numbers === null || (is_array($page_numbers) && count($page_numbers) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_numbers when calling redactPdfManual'
            );
        }

        // verify the required parameter 'redactions' is set
        if ($redactions === null || (is_array($redactions) && count($redactions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $redactions when calling redactPdfManual'
            );
        }

        // verify the required parameter 'convert_pdfto_image' is set
        if ($convert_pdfto_image === null || (is_array($convert_pdfto_image) && count($convert_pdfto_image) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $convert_pdfto_image when calling redactPdfManual'
            );
        }

        // verify the required parameter 'page_redaction_color' is set
        if ($page_redaction_color === null || (is_array($page_redaction_color) && count($page_redaction_color) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_redaction_color when calling redactPdfManual'
            );
        }




        $resourcePath = '/api/v1/security/redact';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'page_numbers' => $page_numbers,
            'redactions' => $redactions,
            'convert_pdfto_image' => $convert_pdfto_image,
            'page_redaction_color' => $page_redaction_color,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeCertSignPDF
     *
     * Remove digital signature from PDF
     *
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeCertSignPDF'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function removeCertSignPDF($file_input = null, $file_id = null, string $contentType = self::contentTypes['removeCertSignPDF'][0])
    {
        list($response) = $this->removeCertSignPDFWithHttpInfo($file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation removeCertSignPDFWithHttpInfo
     *
     * Remove digital signature from PDF
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeCertSignPDF'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeCertSignPDFWithHttpInfo($file_input = null, $file_id = null, string $contentType = self::contentTypes['removeCertSignPDF'][0])
    {
        $request = $this->removeCertSignPDFRequest($file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation removeCertSignPDFAsync
     *
     * Remove digital signature from PDF
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeCertSignPDF'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeCertSignPDFAsync($file_input = null, $file_id = null, string $contentType = self::contentTypes['removeCertSignPDF'][0])
    {
        return $this->removeCertSignPDFAsyncWithHttpInfo($file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeCertSignPDFAsyncWithHttpInfo
     *
     * Remove digital signature from PDF
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeCertSignPDF'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeCertSignPDFAsyncWithHttpInfo($file_input = null, $file_id = null, string $contentType = self::contentTypes['removeCertSignPDF'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->removeCertSignPDFRequest($file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeCertSignPDF'
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeCertSignPDF'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function removeCertSignPDFRequest($file_input = null, $file_id = null, string $contentType = self::contentTypes['removeCertSignPDF'][0])
    {




        $resourcePath = '/api/v1/security/remove-cert-sign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removePassword
     *
     * Remove password from a PDF file
     *
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $password The password of the PDF file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removePassword'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function removePassword($file_input = null, $file_id = null, $password = null, string $contentType = self::contentTypes['removePassword'][0])
    {
        list($response) = $this->removePasswordWithHttpInfo($file_input, $file_id, $password, $contentType);
        return $response;
    }

    /**
     * Operation removePasswordWithHttpInfo
     *
     * Remove password from a PDF file
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $password The password of the PDF file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removePassword'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function removePasswordWithHttpInfo($file_input = null, $file_id = null, $password = null, string $contentType = self::contentTypes['removePassword'][0])
    {
        $request = $this->removePasswordRequest($file_input, $file_id, $password, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation removePasswordAsync
     *
     * Remove password from a PDF file
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $password The password of the PDF file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removePassword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removePasswordAsync($file_input = null, $file_id = null, $password = null, string $contentType = self::contentTypes['removePassword'][0])
    {
        return $this->removePasswordAsyncWithHttpInfo($file_input, $file_id, $password, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removePasswordAsyncWithHttpInfo
     *
     * Remove password from a PDF file
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $password The password of the PDF file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removePassword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removePasswordAsyncWithHttpInfo($file_input = null, $file_id = null, $password = null, string $contentType = self::contentTypes['removePassword'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->removePasswordRequest($file_input, $file_id, $password, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removePassword'
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $password The password of the PDF file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removePassword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function removePasswordRequest($file_input = null, $file_id = null, $password = null, string $contentType = self::contentTypes['removePassword'][0])
    {





        $resourcePath = '/api/v1/security/remove-password';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'password' => $password,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sanitizePDF
     *
     * Sanitize a PDF file
     *
     * @param  bool $remove_java_script Remove JavaScript actions from the PDF (required)
     * @param  bool $remove_embedded_files Remove embedded files from the PDF (required)
     * @param  bool $remove_xmp_metadata Remove XMP metadata from the PDF (required)
     * @param  bool $remove_metadata Remove document info metadata from the PDF (required)
     * @param  bool $remove_links Remove links from the PDF (required)
     * @param  bool $remove_fonts Remove fonts from the PDF (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sanitizePDF'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function sanitizePDF($remove_java_script, $remove_embedded_files, $remove_xmp_metadata, $remove_metadata, $remove_links, $remove_fonts, $file_input = null, $file_id = null, string $contentType = self::contentTypes['sanitizePDF'][0])
    {
        list($response) = $this->sanitizePDFWithHttpInfo($remove_java_script, $remove_embedded_files, $remove_xmp_metadata, $remove_metadata, $remove_links, $remove_fonts, $file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation sanitizePDFWithHttpInfo
     *
     * Sanitize a PDF file
     *
     * @param  bool $remove_java_script Remove JavaScript actions from the PDF (required)
     * @param  bool $remove_embedded_files Remove embedded files from the PDF (required)
     * @param  bool $remove_xmp_metadata Remove XMP metadata from the PDF (required)
     * @param  bool $remove_metadata Remove document info metadata from the PDF (required)
     * @param  bool $remove_links Remove links from the PDF (required)
     * @param  bool $remove_fonts Remove fonts from the PDF (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sanitizePDF'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function sanitizePDFWithHttpInfo($remove_java_script, $remove_embedded_files, $remove_xmp_metadata, $remove_metadata, $remove_links, $remove_fonts, $file_input = null, $file_id = null, string $contentType = self::contentTypes['sanitizePDF'][0])
    {
        $request = $this->sanitizePDFRequest($remove_java_script, $remove_embedded_files, $remove_xmp_metadata, $remove_metadata, $remove_links, $remove_fonts, $file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation sanitizePDFAsync
     *
     * Sanitize a PDF file
     *
     * @param  bool $remove_java_script Remove JavaScript actions from the PDF (required)
     * @param  bool $remove_embedded_files Remove embedded files from the PDF (required)
     * @param  bool $remove_xmp_metadata Remove XMP metadata from the PDF (required)
     * @param  bool $remove_metadata Remove document info metadata from the PDF (required)
     * @param  bool $remove_links Remove links from the PDF (required)
     * @param  bool $remove_fonts Remove fonts from the PDF (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sanitizePDF'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sanitizePDFAsync($remove_java_script, $remove_embedded_files, $remove_xmp_metadata, $remove_metadata, $remove_links, $remove_fonts, $file_input = null, $file_id = null, string $contentType = self::contentTypes['sanitizePDF'][0])
    {
        return $this->sanitizePDFAsyncWithHttpInfo($remove_java_script, $remove_embedded_files, $remove_xmp_metadata, $remove_metadata, $remove_links, $remove_fonts, $file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sanitizePDFAsyncWithHttpInfo
     *
     * Sanitize a PDF file
     *
     * @param  bool $remove_java_script Remove JavaScript actions from the PDF (required)
     * @param  bool $remove_embedded_files Remove embedded files from the PDF (required)
     * @param  bool $remove_xmp_metadata Remove XMP metadata from the PDF (required)
     * @param  bool $remove_metadata Remove document info metadata from the PDF (required)
     * @param  bool $remove_links Remove links from the PDF (required)
     * @param  bool $remove_fonts Remove fonts from the PDF (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sanitizePDF'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sanitizePDFAsyncWithHttpInfo($remove_java_script, $remove_embedded_files, $remove_xmp_metadata, $remove_metadata, $remove_links, $remove_fonts, $file_input = null, $file_id = null, string $contentType = self::contentTypes['sanitizePDF'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->sanitizePDFRequest($remove_java_script, $remove_embedded_files, $remove_xmp_metadata, $remove_metadata, $remove_links, $remove_fonts, $file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sanitizePDF'
     *
     * @param  bool $remove_java_script Remove JavaScript actions from the PDF (required)
     * @param  bool $remove_embedded_files Remove embedded files from the PDF (required)
     * @param  bool $remove_xmp_metadata Remove XMP metadata from the PDF (required)
     * @param  bool $remove_metadata Remove document info metadata from the PDF (required)
     * @param  bool $remove_links Remove links from the PDF (required)
     * @param  bool $remove_fonts Remove fonts from the PDF (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sanitizePDF'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sanitizePDFRequest($remove_java_script, $remove_embedded_files, $remove_xmp_metadata, $remove_metadata, $remove_links, $remove_fonts, $file_input = null, $file_id = null, string $contentType = self::contentTypes['sanitizePDF'][0])
    {

        // verify the required parameter 'remove_java_script' is set
        if ($remove_java_script === null || (is_array($remove_java_script) && count($remove_java_script) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remove_java_script when calling sanitizePDF'
            );
        }

        // verify the required parameter 'remove_embedded_files' is set
        if ($remove_embedded_files === null || (is_array($remove_embedded_files) && count($remove_embedded_files) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remove_embedded_files when calling sanitizePDF'
            );
        }

        // verify the required parameter 'remove_xmp_metadata' is set
        if ($remove_xmp_metadata === null || (is_array($remove_xmp_metadata) && count($remove_xmp_metadata) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remove_xmp_metadata when calling sanitizePDF'
            );
        }

        // verify the required parameter 'remove_metadata' is set
        if ($remove_metadata === null || (is_array($remove_metadata) && count($remove_metadata) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remove_metadata when calling sanitizePDF'
            );
        }

        // verify the required parameter 'remove_links' is set
        if ($remove_links === null || (is_array($remove_links) && count($remove_links) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remove_links when calling sanitizePDF'
            );
        }

        // verify the required parameter 'remove_fonts' is set
        if ($remove_fonts === null || (is_array($remove_fonts) && count($remove_fonts) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remove_fonts when calling sanitizePDF'
            );
        }




        $resourcePath = '/api/v1/security/sanitize-pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'remove_java_script' => $remove_java_script,
            'remove_embedded_files' => $remove_embedded_files,
            'remove_xmp_metadata' => $remove_xmp_metadata,
            'remove_metadata' => $remove_metadata,
            'remove_links' => $remove_links,
            'remove_fonts' => $remove_fonts,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation signPDFWithCert
     *
     * Sign PDF with a Digital Certificate
     *
     * @param  string $cert_type The type of the digital certificate (required)
     * @param  bool $show_signature Whether to visually show the signature in the PDF file (required)
     * @param  bool $show_logo Whether to visually show a signature logo along with the signature (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  \SplFileObject|null $private_key_file private_key_file (optional)
     * @param  \SplFileObject|null $cert_file cert_file (optional)
     * @param  \SplFileObject|null $p12_file p12_file (optional)
     * @param  \SplFileObject|null $jks_file jks_file (optional)
     * @param  string|null $password The password for the keystore or the private key (optional)
     * @param  string|null $reason The reason for signing the PDF (optional, default to 'Signed by SPDF')
     * @param  string|null $location The location where the PDF is signed (optional, default to 'SPDF')
     * @param  string|null $name The name of the signer (optional, default to 'SPDF')
     * @param  int|null $page_number The page number where the signature should be visible. This is required if showSignature is set to true (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['signPDFWithCert'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function signPDFWithCert($cert_type, $show_signature, $show_logo, $file_input = null, $file_id = null, $private_key_file = null, $cert_file = null, $p12_file = null, $jks_file = null, $password = null, $reason = 'Signed by SPDF', $location = 'SPDF', $name = 'SPDF', $page_number = 1, string $contentType = self::contentTypes['signPDFWithCert'][0])
    {
        list($response) = $this->signPDFWithCertWithHttpInfo($cert_type, $show_signature, $show_logo, $file_input, $file_id, $private_key_file, $cert_file, $p12_file, $jks_file, $password, $reason, $location, $name, $page_number, $contentType);
        return $response;
    }

    /**
     * Operation signPDFWithCertWithHttpInfo
     *
     * Sign PDF with a Digital Certificate
     *
     * @param  string $cert_type The type of the digital certificate (required)
     * @param  bool $show_signature Whether to visually show the signature in the PDF file (required)
     * @param  bool $show_logo Whether to visually show a signature logo along with the signature (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  \SplFileObject|null $private_key_file (optional)
     * @param  \SplFileObject|null $cert_file (optional)
     * @param  \SplFileObject|null $p12_file (optional)
     * @param  \SplFileObject|null $jks_file (optional)
     * @param  string|null $password The password for the keystore or the private key (optional)
     * @param  string|null $reason The reason for signing the PDF (optional, default to 'Signed by SPDF')
     * @param  string|null $location The location where the PDF is signed (optional, default to 'SPDF')
     * @param  string|null $name The name of the signer (optional, default to 'SPDF')
     * @param  int|null $page_number The page number where the signature should be visible. This is required if showSignature is set to true (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['signPDFWithCert'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function signPDFWithCertWithHttpInfo($cert_type, $show_signature, $show_logo, $file_input = null, $file_id = null, $private_key_file = null, $cert_file = null, $p12_file = null, $jks_file = null, $password = null, $reason = 'Signed by SPDF', $location = 'SPDF', $name = 'SPDF', $page_number = 1, string $contentType = self::contentTypes['signPDFWithCert'][0])
    {
        $request = $this->signPDFWithCertRequest($cert_type, $show_signature, $show_logo, $file_input, $file_id, $private_key_file, $cert_file, $p12_file, $jks_file, $password, $reason, $location, $name, $page_number, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation signPDFWithCertAsync
     *
     * Sign PDF with a Digital Certificate
     *
     * @param  string $cert_type The type of the digital certificate (required)
     * @param  bool $show_signature Whether to visually show the signature in the PDF file (required)
     * @param  bool $show_logo Whether to visually show a signature logo along with the signature (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  \SplFileObject|null $private_key_file (optional)
     * @param  \SplFileObject|null $cert_file (optional)
     * @param  \SplFileObject|null $p12_file (optional)
     * @param  \SplFileObject|null $jks_file (optional)
     * @param  string|null $password The password for the keystore or the private key (optional)
     * @param  string|null $reason The reason for signing the PDF (optional, default to 'Signed by SPDF')
     * @param  string|null $location The location where the PDF is signed (optional, default to 'SPDF')
     * @param  string|null $name The name of the signer (optional, default to 'SPDF')
     * @param  int|null $page_number The page number where the signature should be visible. This is required if showSignature is set to true (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['signPDFWithCert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signPDFWithCertAsync($cert_type, $show_signature, $show_logo, $file_input = null, $file_id = null, $private_key_file = null, $cert_file = null, $p12_file = null, $jks_file = null, $password = null, $reason = 'Signed by SPDF', $location = 'SPDF', $name = 'SPDF', $page_number = 1, string $contentType = self::contentTypes['signPDFWithCert'][0])
    {
        return $this->signPDFWithCertAsyncWithHttpInfo($cert_type, $show_signature, $show_logo, $file_input, $file_id, $private_key_file, $cert_file, $p12_file, $jks_file, $password, $reason, $location, $name, $page_number, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation signPDFWithCertAsyncWithHttpInfo
     *
     * Sign PDF with a Digital Certificate
     *
     * @param  string $cert_type The type of the digital certificate (required)
     * @param  bool $show_signature Whether to visually show the signature in the PDF file (required)
     * @param  bool $show_logo Whether to visually show a signature logo along with the signature (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  \SplFileObject|null $private_key_file (optional)
     * @param  \SplFileObject|null $cert_file (optional)
     * @param  \SplFileObject|null $p12_file (optional)
     * @param  \SplFileObject|null $jks_file (optional)
     * @param  string|null $password The password for the keystore or the private key (optional)
     * @param  string|null $reason The reason for signing the PDF (optional, default to 'Signed by SPDF')
     * @param  string|null $location The location where the PDF is signed (optional, default to 'SPDF')
     * @param  string|null $name The name of the signer (optional, default to 'SPDF')
     * @param  int|null $page_number The page number where the signature should be visible. This is required if showSignature is set to true (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['signPDFWithCert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signPDFWithCertAsyncWithHttpInfo($cert_type, $show_signature, $show_logo, $file_input = null, $file_id = null, $private_key_file = null, $cert_file = null, $p12_file = null, $jks_file = null, $password = null, $reason = 'Signed by SPDF', $location = 'SPDF', $name = 'SPDF', $page_number = 1, string $contentType = self::contentTypes['signPDFWithCert'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->signPDFWithCertRequest($cert_type, $show_signature, $show_logo, $file_input, $file_id, $private_key_file, $cert_file, $p12_file, $jks_file, $password, $reason, $location, $name, $page_number, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'signPDFWithCert'
     *
     * @param  string $cert_type The type of the digital certificate (required)
     * @param  bool $show_signature Whether to visually show the signature in the PDF file (required)
     * @param  bool $show_logo Whether to visually show a signature logo along with the signature (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  \SplFileObject|null $private_key_file (optional)
     * @param  \SplFileObject|null $cert_file (optional)
     * @param  \SplFileObject|null $p12_file (optional)
     * @param  \SplFileObject|null $jks_file (optional)
     * @param  string|null $password The password for the keystore or the private key (optional)
     * @param  string|null $reason The reason for signing the PDF (optional, default to 'Signed by SPDF')
     * @param  string|null $location The location where the PDF is signed (optional, default to 'SPDF')
     * @param  string|null $name The name of the signer (optional, default to 'SPDF')
     * @param  int|null $page_number The page number where the signature should be visible. This is required if showSignature is set to true (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['signPDFWithCert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function signPDFWithCertRequest($cert_type, $show_signature, $show_logo, $file_input = null, $file_id = null, $private_key_file = null, $cert_file = null, $p12_file = null, $jks_file = null, $password = null, $reason = 'Signed by SPDF', $location = 'SPDF', $name = 'SPDF', $page_number = 1, string $contentType = self::contentTypes['signPDFWithCert'][0])
    {

        // verify the required parameter 'cert_type' is set
        if ($cert_type === null || (is_array($cert_type) && count($cert_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cert_type when calling signPDFWithCert'
            );
        }

        // verify the required parameter 'show_signature' is set
        if ($show_signature === null || (is_array($show_signature) && count($show_signature) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $show_signature when calling signPDFWithCert'
            );
        }

        // verify the required parameter 'show_logo' is set
        if ($show_logo === null || (is_array($show_logo) && count($show_logo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $show_logo when calling signPDFWithCert'
            );
        }













        $resourcePath = '/api/v1/security/cert-sign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'cert_type' => $cert_type,
            'private_key_file' => $private_key_file,
            'cert_file' => $cert_file,
            'p12_file' => $p12_file,
            'jks_file' => $jks_file,
            'password' => $password,
            'show_signature' => $show_signature,
            'reason' => $reason,
            'location' => $location,
            'name' => $name,
            'page_number' => $page_number,
            'show_logo' => $show_logo,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validateSignature
     *
     * Validate PDF Digital Signature
     *
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  \SplFileObject|null $cert_file cert_file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateSignature'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function validateSignature($file_input = null, $file_id = null, $cert_file = null, string $contentType = self::contentTypes['validateSignature'][0])
    {
        list($response) = $this->validateSignatureWithHttpInfo($file_input, $file_id, $cert_file, $contentType);
        return $response;
    }

    /**
     * Operation validateSignatureWithHttpInfo
     *
     * Validate PDF Digital Signature
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  \SplFileObject|null $cert_file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateSignature'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function validateSignatureWithHttpInfo($file_input = null, $file_id = null, $cert_file = null, string $contentType = self::contentTypes['validateSignature'][0])
    {
        $request = $this->validateSignatureRequest($file_input, $file_id, $cert_file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'object',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation validateSignatureAsync
     *
     * Validate PDF Digital Signature
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  \SplFileObject|null $cert_file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateSignature'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateSignatureAsync($file_input = null, $file_id = null, $cert_file = null, string $contentType = self::contentTypes['validateSignature'][0])
    {
        return $this->validateSignatureAsyncWithHttpInfo($file_input, $file_id, $cert_file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validateSignatureAsyncWithHttpInfo
     *
     * Validate PDF Digital Signature
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  \SplFileObject|null $cert_file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateSignature'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateSignatureAsyncWithHttpInfo($file_input = null, $file_id = null, $cert_file = null, string $contentType = self::contentTypes['validateSignature'][0])
    {
        $returnType = 'object';
        $request = $this->validateSignatureRequest($file_input, $file_id, $cert_file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validateSignature'
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  \SplFileObject|null $cert_file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateSignature'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function validateSignatureRequest($file_input = null, $file_id = null, $cert_file = null, string $contentType = self::contentTypes['validateSignature'][0])
    {





        $resourcePath = '/api/v1/security/validate-signature';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'cert_file' => $cert_file,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
