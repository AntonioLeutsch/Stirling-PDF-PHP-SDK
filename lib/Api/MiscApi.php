<?php
/**
 * MiscApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Stirling PDF - Processing API
 *
 * API documentation for PDF processing operations including conversion, manipulation, security, and utilities. Please note all requests require authentication and as such should have a 'X-API-KEY' provided in their header
 *
 * The version of the OpenAPI document: 1.0.1
 * Contact: contact@stirlingpdf.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.19.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * MiscApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class MiscApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'addAttachments' => [
            'multipart/form-data',
        ],
        'addPageNumbers' => [
            'multipart/form-data',
        ],
        'addStamp' => [
            'multipart/form-data',
        ],
        'autoSplitPdf' => [
            'multipart/form-data',
        ],
        'decompressPdf' => [
            'multipart/form-data',
        ],
        'extractHeader' => [
            'multipart/form-data',
        ],
        'extractHeader1' => [
            'multipart/form-data',
        ],
        'extractImageScans' => [
            'multipart/form-data',
        ],
        'extractImages' => [
            'multipart/form-data',
        ],
        'flatten' => [
            'multipart/form-data',
        ],
        'metadata' => [
            'multipart/form-data',
        ],
        'optimizePdf' => [
            'multipart/form-data',
        ],
        'overlayImage' => [
            'multipart/form-data',
        ],
        'processPdfWithOCR' => [
            'multipart/form-data',
        ],
        'removeBlankPages' => [
            'multipart/form-data',
        ],
        'repairPdf' => [
            'multipart/form-data',
        ],
        'replaceAndInvertColor' => [
            'multipart/form-data',
        ],
        'scannerEffect' => [
            'multipart/form-data',
        ],
        'unlockPDFForms' => [
            'multipart/form-data',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addAttachments
     *
     * Add attachments to PDF
     *
     * @param  \SplFileObject[] $attachments The image file to be overlaid onto the PDF. (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addAttachments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function addAttachments($attachments, $file_input = null, $file_id = null, string $contentType = self::contentTypes['addAttachments'][0])
    {
        list($response) = $this->addAttachmentsWithHttpInfo($attachments, $file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation addAttachmentsWithHttpInfo
     *
     * Add attachments to PDF
     *
     * @param  \SplFileObject[] $attachments The image file to be overlaid onto the PDF. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addAttachments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function addAttachmentsWithHttpInfo($attachments, $file_input = null, $file_id = null, string $contentType = self::contentTypes['addAttachments'][0])
    {
        $request = $this->addAttachmentsRequest($attachments, $file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation addAttachmentsAsync
     *
     * Add attachments to PDF
     *
     * @param  \SplFileObject[] $attachments The image file to be overlaid onto the PDF. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addAttachments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addAttachmentsAsync($attachments, $file_input = null, $file_id = null, string $contentType = self::contentTypes['addAttachments'][0])
    {
        return $this->addAttachmentsAsyncWithHttpInfo($attachments, $file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addAttachmentsAsyncWithHttpInfo
     *
     * Add attachments to PDF
     *
     * @param  \SplFileObject[] $attachments The image file to be overlaid onto the PDF. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addAttachments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addAttachmentsAsyncWithHttpInfo($attachments, $file_input = null, $file_id = null, string $contentType = self::contentTypes['addAttachments'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->addAttachmentsRequest($attachments, $file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addAttachments'
     *
     * @param  \SplFileObject[] $attachments The image file to be overlaid onto the PDF. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addAttachments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addAttachmentsRequest($attachments, $file_input = null, $file_id = null, string $contentType = self::contentTypes['addAttachments'][0])
    {

        // verify the required parameter 'attachments' is set
        if ($attachments === null || (is_array($attachments) && count($attachments) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attachments when calling addAttachments'
            );
        }




        $resourcePath = '/api/v1/misc/add-attachments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'attachments' => $attachments,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addPageNumbers
     *
     * Add page numbers to a PDF document
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  float $font_size Font size for page numbers (required)
     * @param  string $font_type Font type for page numbers (required)
     * @param  int $position Position: 1-9 representing positions on the page (1&#x3D;top-left, 2&#x3D;top-center, 3&#x3D;top-right, 4&#x3D;middle-left, 5&#x3D;middle-center, 6&#x3D;middle-right, 7&#x3D;bottom-left, 8&#x3D;bottom-center, 9&#x3D;bottom-right) (required)
     * @param  int $starting_number Starting number for page numbering (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $custom_margin Custom margin: small/medium/large/x-large (optional, default to 'medium')
     * @param  string|null $pages_to_number Which pages to number (e.g. &#39;1,3-5,7&#39; or &#39;all&#39;) (optional, default to 'all')
     * @param  string|null $custom_text Custom text pattern. Available variables: {n}&#x3D;current page number, {total}&#x3D;total pages, {filename}&#x3D;original filename (optional, default to '{n}')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addPageNumbers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function addPageNumbers($page_numbers, $font_size, $font_type, $position, $starting_number, $file_input = null, $file_id = null, $custom_margin = 'medium', $pages_to_number = 'all', $custom_text = '{n}', string $contentType = self::contentTypes['addPageNumbers'][0])
    {
        list($response) = $this->addPageNumbersWithHttpInfo($page_numbers, $font_size, $font_type, $position, $starting_number, $file_input, $file_id, $custom_margin, $pages_to_number, $custom_text, $contentType);
        return $response;
    }

    /**
     * Operation addPageNumbersWithHttpInfo
     *
     * Add page numbers to a PDF document
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  float $font_size Font size for page numbers (required)
     * @param  string $font_type Font type for page numbers (required)
     * @param  int $position Position: 1-9 representing positions on the page (1&#x3D;top-left, 2&#x3D;top-center, 3&#x3D;top-right, 4&#x3D;middle-left, 5&#x3D;middle-center, 6&#x3D;middle-right, 7&#x3D;bottom-left, 8&#x3D;bottom-center, 9&#x3D;bottom-right) (required)
     * @param  int $starting_number Starting number for page numbering (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $custom_margin Custom margin: small/medium/large/x-large (optional, default to 'medium')
     * @param  string|null $pages_to_number Which pages to number (e.g. &#39;1,3-5,7&#39; or &#39;all&#39;) (optional, default to 'all')
     * @param  string|null $custom_text Custom text pattern. Available variables: {n}&#x3D;current page number, {total}&#x3D;total pages, {filename}&#x3D;original filename (optional, default to '{n}')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addPageNumbers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function addPageNumbersWithHttpInfo($page_numbers, $font_size, $font_type, $position, $starting_number, $file_input = null, $file_id = null, $custom_margin = 'medium', $pages_to_number = 'all', $custom_text = '{n}', string $contentType = self::contentTypes['addPageNumbers'][0])
    {
        $request = $this->addPageNumbersRequest($page_numbers, $font_size, $font_type, $position, $starting_number, $file_input, $file_id, $custom_margin, $pages_to_number, $custom_text, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation addPageNumbersAsync
     *
     * Add page numbers to a PDF document
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  float $font_size Font size for page numbers (required)
     * @param  string $font_type Font type for page numbers (required)
     * @param  int $position Position: 1-9 representing positions on the page (1&#x3D;top-left, 2&#x3D;top-center, 3&#x3D;top-right, 4&#x3D;middle-left, 5&#x3D;middle-center, 6&#x3D;middle-right, 7&#x3D;bottom-left, 8&#x3D;bottom-center, 9&#x3D;bottom-right) (required)
     * @param  int $starting_number Starting number for page numbering (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $custom_margin Custom margin: small/medium/large/x-large (optional, default to 'medium')
     * @param  string|null $pages_to_number Which pages to number (e.g. &#39;1,3-5,7&#39; or &#39;all&#39;) (optional, default to 'all')
     * @param  string|null $custom_text Custom text pattern. Available variables: {n}&#x3D;current page number, {total}&#x3D;total pages, {filename}&#x3D;original filename (optional, default to '{n}')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addPageNumbers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addPageNumbersAsync($page_numbers, $font_size, $font_type, $position, $starting_number, $file_input = null, $file_id = null, $custom_margin = 'medium', $pages_to_number = 'all', $custom_text = '{n}', string $contentType = self::contentTypes['addPageNumbers'][0])
    {
        return $this->addPageNumbersAsyncWithHttpInfo($page_numbers, $font_size, $font_type, $position, $starting_number, $file_input, $file_id, $custom_margin, $pages_to_number, $custom_text, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addPageNumbersAsyncWithHttpInfo
     *
     * Add page numbers to a PDF document
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  float $font_size Font size for page numbers (required)
     * @param  string $font_type Font type for page numbers (required)
     * @param  int $position Position: 1-9 representing positions on the page (1&#x3D;top-left, 2&#x3D;top-center, 3&#x3D;top-right, 4&#x3D;middle-left, 5&#x3D;middle-center, 6&#x3D;middle-right, 7&#x3D;bottom-left, 8&#x3D;bottom-center, 9&#x3D;bottom-right) (required)
     * @param  int $starting_number Starting number for page numbering (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $custom_margin Custom margin: small/medium/large/x-large (optional, default to 'medium')
     * @param  string|null $pages_to_number Which pages to number (e.g. &#39;1,3-5,7&#39; or &#39;all&#39;) (optional, default to 'all')
     * @param  string|null $custom_text Custom text pattern. Available variables: {n}&#x3D;current page number, {total}&#x3D;total pages, {filename}&#x3D;original filename (optional, default to '{n}')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addPageNumbers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addPageNumbersAsyncWithHttpInfo($page_numbers, $font_size, $font_type, $position, $starting_number, $file_input = null, $file_id = null, $custom_margin = 'medium', $pages_to_number = 'all', $custom_text = '{n}', string $contentType = self::contentTypes['addPageNumbers'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->addPageNumbersRequest($page_numbers, $font_size, $font_type, $position, $starting_number, $file_input, $file_id, $custom_margin, $pages_to_number, $custom_text, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addPageNumbers'
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  float $font_size Font size for page numbers (required)
     * @param  string $font_type Font type for page numbers (required)
     * @param  int $position Position: 1-9 representing positions on the page (1&#x3D;top-left, 2&#x3D;top-center, 3&#x3D;top-right, 4&#x3D;middle-left, 5&#x3D;middle-center, 6&#x3D;middle-right, 7&#x3D;bottom-left, 8&#x3D;bottom-center, 9&#x3D;bottom-right) (required)
     * @param  int $starting_number Starting number for page numbering (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $custom_margin Custom margin: small/medium/large/x-large (optional, default to 'medium')
     * @param  string|null $pages_to_number Which pages to number (e.g. &#39;1,3-5,7&#39; or &#39;all&#39;) (optional, default to 'all')
     * @param  string|null $custom_text Custom text pattern. Available variables: {n}&#x3D;current page number, {total}&#x3D;total pages, {filename}&#x3D;original filename (optional, default to '{n}')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addPageNumbers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addPageNumbersRequest($page_numbers, $font_size, $font_type, $position, $starting_number, $file_input = null, $file_id = null, $custom_margin = 'medium', $pages_to_number = 'all', $custom_text = '{n}', string $contentType = self::contentTypes['addPageNumbers'][0])
    {

        // verify the required parameter 'page_numbers' is set
        if ($page_numbers === null || (is_array($page_numbers) && count($page_numbers) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_numbers when calling addPageNumbers'
            );
        }

        // verify the required parameter 'font_size' is set
        if ($font_size === null || (is_array($font_size) && count($font_size) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $font_size when calling addPageNumbers'
            );
        }
        if ($font_size < 1) {
            throw new \InvalidArgumentException('invalid value for "$font_size" when calling MiscApi.addPageNumbers, must be bigger than or equal to 1.');
        }
        
        // verify the required parameter 'font_type' is set
        if ($font_type === null || (is_array($font_type) && count($font_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $font_type when calling addPageNumbers'
            );
        }

        // verify the required parameter 'position' is set
        if ($position === null || (is_array($position) && count($position) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $position when calling addPageNumbers'
            );
        }

        // verify the required parameter 'starting_number' is set
        if ($starting_number === null || (is_array($starting_number) && count($starting_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $starting_number when calling addPageNumbers'
            );
        }
        if ($starting_number < 1) {
            throw new \InvalidArgumentException('invalid value for "$starting_number" when calling MiscApi.addPageNumbers, must be bigger than or equal to 1.');
        }
        






        $resourcePath = '/api/v1/misc/add-page-numbers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'page_numbers' => $page_numbers,
            'custom_margin' => $custom_margin,
            'font_size' => $font_size,
            'font_type' => $font_type,
            'position' => $position,
            'starting_number' => $starting_number,
            'pages_to_number' => $pages_to_number,
            'custom_text' => $custom_text,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addStamp
     *
     * Add stamp to a PDF file
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  string $stamp_type The stamp type (text or image) (required)
     * @param  float $font_size The font size of the stamp text and image (required)
     * @param  float $rotation The rotation of the stamp in degrees (required)
     * @param  float $opacity The opacity of the stamp (0.0 - 1.0) (required)
     * @param  int $position Position for stamp placement based on a 1-9 grid (1: bottom-left, 2: bottom-center, 3: bottom-right, 4: middle-left, 5: middle-center, 6: middle-right, 7: top-left, 8: top-center, 9: top-right) (required)
     * @param  float $override_x Override X coordinate for stamp placement. If set, it will override the position-based calculation. Negative value means no override. (required)
     * @param  float $override_y Override Y coordinate for stamp placement. If set, it will override the position-based calculation. Negative value means no override. (required)
     * @param  string $custom_margin Specifies the margin size for the stamp. (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $stamp_text The stamp text (optional, default to 'Stirling Software')
     * @param  \SplFileObject|null $stamp_image stamp_image (optional)
     * @param  string|null $alphabet The selected alphabet of the stamp text (optional, default to 'roman')
     * @param  string|null $custom_color The color of the stamp text (optional, default to '#d3d3d3')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addStamp'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function addStamp($page_numbers, $stamp_type, $font_size, $rotation, $opacity, $position, $override_x, $override_y, $custom_margin, $file_input = null, $file_id = null, $stamp_text = 'Stirling Software', $stamp_image = null, $alphabet = 'roman', $custom_color = '#d3d3d3', string $contentType = self::contentTypes['addStamp'][0])
    {
        list($response) = $this->addStampWithHttpInfo($page_numbers, $stamp_type, $font_size, $rotation, $opacity, $position, $override_x, $override_y, $custom_margin, $file_input, $file_id, $stamp_text, $stamp_image, $alphabet, $custom_color, $contentType);
        return $response;
    }

    /**
     * Operation addStampWithHttpInfo
     *
     * Add stamp to a PDF file
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  string $stamp_type The stamp type (text or image) (required)
     * @param  float $font_size The font size of the stamp text and image (required)
     * @param  float $rotation The rotation of the stamp in degrees (required)
     * @param  float $opacity The opacity of the stamp (0.0 - 1.0) (required)
     * @param  int $position Position for stamp placement based on a 1-9 grid (1: bottom-left, 2: bottom-center, 3: bottom-right, 4: middle-left, 5: middle-center, 6: middle-right, 7: top-left, 8: top-center, 9: top-right) (required)
     * @param  float $override_x Override X coordinate for stamp placement. If set, it will override the position-based calculation. Negative value means no override. (required)
     * @param  float $override_y Override Y coordinate for stamp placement. If set, it will override the position-based calculation. Negative value means no override. (required)
     * @param  string $custom_margin Specifies the margin size for the stamp. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $stamp_text The stamp text (optional, default to 'Stirling Software')
     * @param  \SplFileObject|null $stamp_image (optional)
     * @param  string|null $alphabet The selected alphabet of the stamp text (optional, default to 'roman')
     * @param  string|null $custom_color The color of the stamp text (optional, default to '#d3d3d3')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addStamp'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function addStampWithHttpInfo($page_numbers, $stamp_type, $font_size, $rotation, $opacity, $position, $override_x, $override_y, $custom_margin, $file_input = null, $file_id = null, $stamp_text = 'Stirling Software', $stamp_image = null, $alphabet = 'roman', $custom_color = '#d3d3d3', string $contentType = self::contentTypes['addStamp'][0])
    {
        $request = $this->addStampRequest($page_numbers, $stamp_type, $font_size, $rotation, $opacity, $position, $override_x, $override_y, $custom_margin, $file_input, $file_id, $stamp_text, $stamp_image, $alphabet, $custom_color, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation addStampAsync
     *
     * Add stamp to a PDF file
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  string $stamp_type The stamp type (text or image) (required)
     * @param  float $font_size The font size of the stamp text and image (required)
     * @param  float $rotation The rotation of the stamp in degrees (required)
     * @param  float $opacity The opacity of the stamp (0.0 - 1.0) (required)
     * @param  int $position Position for stamp placement based on a 1-9 grid (1: bottom-left, 2: bottom-center, 3: bottom-right, 4: middle-left, 5: middle-center, 6: middle-right, 7: top-left, 8: top-center, 9: top-right) (required)
     * @param  float $override_x Override X coordinate for stamp placement. If set, it will override the position-based calculation. Negative value means no override. (required)
     * @param  float $override_y Override Y coordinate for stamp placement. If set, it will override the position-based calculation. Negative value means no override. (required)
     * @param  string $custom_margin Specifies the margin size for the stamp. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $stamp_text The stamp text (optional, default to 'Stirling Software')
     * @param  \SplFileObject|null $stamp_image (optional)
     * @param  string|null $alphabet The selected alphabet of the stamp text (optional, default to 'roman')
     * @param  string|null $custom_color The color of the stamp text (optional, default to '#d3d3d3')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addStamp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addStampAsync($page_numbers, $stamp_type, $font_size, $rotation, $opacity, $position, $override_x, $override_y, $custom_margin, $file_input = null, $file_id = null, $stamp_text = 'Stirling Software', $stamp_image = null, $alphabet = 'roman', $custom_color = '#d3d3d3', string $contentType = self::contentTypes['addStamp'][0])
    {
        return $this->addStampAsyncWithHttpInfo($page_numbers, $stamp_type, $font_size, $rotation, $opacity, $position, $override_x, $override_y, $custom_margin, $file_input, $file_id, $stamp_text, $stamp_image, $alphabet, $custom_color, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addStampAsyncWithHttpInfo
     *
     * Add stamp to a PDF file
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  string $stamp_type The stamp type (text or image) (required)
     * @param  float $font_size The font size of the stamp text and image (required)
     * @param  float $rotation The rotation of the stamp in degrees (required)
     * @param  float $opacity The opacity of the stamp (0.0 - 1.0) (required)
     * @param  int $position Position for stamp placement based on a 1-9 grid (1: bottom-left, 2: bottom-center, 3: bottom-right, 4: middle-left, 5: middle-center, 6: middle-right, 7: top-left, 8: top-center, 9: top-right) (required)
     * @param  float $override_x Override X coordinate for stamp placement. If set, it will override the position-based calculation. Negative value means no override. (required)
     * @param  float $override_y Override Y coordinate for stamp placement. If set, it will override the position-based calculation. Negative value means no override. (required)
     * @param  string $custom_margin Specifies the margin size for the stamp. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $stamp_text The stamp text (optional, default to 'Stirling Software')
     * @param  \SplFileObject|null $stamp_image (optional)
     * @param  string|null $alphabet The selected alphabet of the stamp text (optional, default to 'roman')
     * @param  string|null $custom_color The color of the stamp text (optional, default to '#d3d3d3')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addStamp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addStampAsyncWithHttpInfo($page_numbers, $stamp_type, $font_size, $rotation, $opacity, $position, $override_x, $override_y, $custom_margin, $file_input = null, $file_id = null, $stamp_text = 'Stirling Software', $stamp_image = null, $alphabet = 'roman', $custom_color = '#d3d3d3', string $contentType = self::contentTypes['addStamp'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->addStampRequest($page_numbers, $stamp_type, $font_size, $rotation, $opacity, $position, $override_x, $override_y, $custom_margin, $file_input, $file_id, $stamp_text, $stamp_image, $alphabet, $custom_color, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addStamp'
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  string $stamp_type The stamp type (text or image) (required)
     * @param  float $font_size The font size of the stamp text and image (required)
     * @param  float $rotation The rotation of the stamp in degrees (required)
     * @param  float $opacity The opacity of the stamp (0.0 - 1.0) (required)
     * @param  int $position Position for stamp placement based on a 1-9 grid (1: bottom-left, 2: bottom-center, 3: bottom-right, 4: middle-left, 5: middle-center, 6: middle-right, 7: top-left, 8: top-center, 9: top-right) (required)
     * @param  float $override_x Override X coordinate for stamp placement. If set, it will override the position-based calculation. Negative value means no override. (required)
     * @param  float $override_y Override Y coordinate for stamp placement. If set, it will override the position-based calculation. Negative value means no override. (required)
     * @param  string $custom_margin Specifies the margin size for the stamp. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $stamp_text The stamp text (optional, default to 'Stirling Software')
     * @param  \SplFileObject|null $stamp_image (optional)
     * @param  string|null $alphabet The selected alphabet of the stamp text (optional, default to 'roman')
     * @param  string|null $custom_color The color of the stamp text (optional, default to '#d3d3d3')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addStamp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addStampRequest($page_numbers, $stamp_type, $font_size, $rotation, $opacity, $position, $override_x, $override_y, $custom_margin, $file_input = null, $file_id = null, $stamp_text = 'Stirling Software', $stamp_image = null, $alphabet = 'roman', $custom_color = '#d3d3d3', string $contentType = self::contentTypes['addStamp'][0])
    {

        // verify the required parameter 'page_numbers' is set
        if ($page_numbers === null || (is_array($page_numbers) && count($page_numbers) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_numbers when calling addStamp'
            );
        }

        // verify the required parameter 'stamp_type' is set
        if ($stamp_type === null || (is_array($stamp_type) && count($stamp_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stamp_type when calling addStamp'
            );
        }

        // verify the required parameter 'font_size' is set
        if ($font_size === null || (is_array($font_size) && count($font_size) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $font_size when calling addStamp'
            );
        }

        // verify the required parameter 'rotation' is set
        if ($rotation === null || (is_array($rotation) && count($rotation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rotation when calling addStamp'
            );
        }

        // verify the required parameter 'opacity' is set
        if ($opacity === null || (is_array($opacity) && count($opacity) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $opacity when calling addStamp'
            );
        }

        // verify the required parameter 'position' is set
        if ($position === null || (is_array($position) && count($position) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $position when calling addStamp'
            );
        }

        // verify the required parameter 'override_x' is set
        if ($override_x === null || (is_array($override_x) && count($override_x) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $override_x when calling addStamp'
            );
        }

        // verify the required parameter 'override_y' is set
        if ($override_y === null || (is_array($override_y) && count($override_y) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $override_y when calling addStamp'
            );
        }

        // verify the required parameter 'custom_margin' is set
        if ($custom_margin === null || (is_array($custom_margin) && count($custom_margin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_margin when calling addStamp'
            );
        }








        $resourcePath = '/api/v1/misc/add-stamp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'page_numbers' => $page_numbers,
            'stamp_type' => $stamp_type,
            'stamp_text' => $stamp_text,
            'stamp_image' => $stamp_image,
            'alphabet' => $alphabet,
            'font_size' => $font_size,
            'rotation' => $rotation,
            'opacity' => $opacity,
            'position' => $position,
            'override_x' => $override_x,
            'override_y' => $override_y,
            'custom_margin' => $custom_margin,
            'custom_color' => $custom_color,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation autoSplitPdf
     *
     * Auto split PDF pages into separate documents
     *
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $duplex_mode Flag indicating if the duplex mode is active, where the page after the divider also gets removed. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autoSplitPdf'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function autoSplitPdf($file_input = null, $file_id = null, $duplex_mode = false, string $contentType = self::contentTypes['autoSplitPdf'][0])
    {
        list($response) = $this->autoSplitPdfWithHttpInfo($file_input, $file_id, $duplex_mode, $contentType);
        return $response;
    }

    /**
     * Operation autoSplitPdfWithHttpInfo
     *
     * Auto split PDF pages into separate documents
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $duplex_mode Flag indicating if the duplex mode is active, where the page after the divider also gets removed. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autoSplitPdf'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function autoSplitPdfWithHttpInfo($file_input = null, $file_id = null, $duplex_mode = false, string $contentType = self::contentTypes['autoSplitPdf'][0])
    {
        $request = $this->autoSplitPdfRequest($file_input, $file_id, $duplex_mode, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation autoSplitPdfAsync
     *
     * Auto split PDF pages into separate documents
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $duplex_mode Flag indicating if the duplex mode is active, where the page after the divider also gets removed. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autoSplitPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autoSplitPdfAsync($file_input = null, $file_id = null, $duplex_mode = false, string $contentType = self::contentTypes['autoSplitPdf'][0])
    {
        return $this->autoSplitPdfAsyncWithHttpInfo($file_input, $file_id, $duplex_mode, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation autoSplitPdfAsyncWithHttpInfo
     *
     * Auto split PDF pages into separate documents
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $duplex_mode Flag indicating if the duplex mode is active, where the page after the divider also gets removed. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autoSplitPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autoSplitPdfAsyncWithHttpInfo($file_input = null, $file_id = null, $duplex_mode = false, string $contentType = self::contentTypes['autoSplitPdf'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->autoSplitPdfRequest($file_input, $file_id, $duplex_mode, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'autoSplitPdf'
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $duplex_mode Flag indicating if the duplex mode is active, where the page after the divider also gets removed. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autoSplitPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function autoSplitPdfRequest($file_input = null, $file_id = null, $duplex_mode = false, string $contentType = self::contentTypes['autoSplitPdf'][0])
    {





        $resourcePath = '/api/v1/misc/auto-split-pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'duplex_mode' => $duplex_mode,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/zip', 'image/png', 'image/jpeg', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation decompressPdf
     *
     * Decompress PDF streams
     *
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['decompressPdf'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function decompressPdf($file_input = null, $file_id = null, string $contentType = self::contentTypes['decompressPdf'][0])
    {
        list($response) = $this->decompressPdfWithHttpInfo($file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation decompressPdfWithHttpInfo
     *
     * Decompress PDF streams
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['decompressPdf'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function decompressPdfWithHttpInfo($file_input = null, $file_id = null, string $contentType = self::contentTypes['decompressPdf'][0])
    {
        $request = $this->decompressPdfRequest($file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'string',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'string',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation decompressPdfAsync
     *
     * Decompress PDF streams
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['decompressPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function decompressPdfAsync($file_input = null, $file_id = null, string $contentType = self::contentTypes['decompressPdf'][0])
    {
        return $this->decompressPdfAsyncWithHttpInfo($file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation decompressPdfAsyncWithHttpInfo
     *
     * Decompress PDF streams
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['decompressPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function decompressPdfAsyncWithHttpInfo($file_input = null, $file_id = null, string $contentType = self::contentTypes['decompressPdf'][0])
    {
        $returnType = 'string';
        $request = $this->decompressPdfRequest($file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'decompressPdf'
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['decompressPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function decompressPdfRequest($file_input = null, $file_id = null, string $contentType = self::contentTypes['decompressPdf'][0])
    {




        $resourcePath = '/api/v1/misc/decompress-pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extractHeader
     *
     * Grabs all JS from a PDF and returns a single JS file with all code
     *
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractHeader'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function extractHeader($file_input = null, $file_id = null, string $contentType = self::contentTypes['extractHeader'][0])
    {
        list($response) = $this->extractHeaderWithHttpInfo($file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation extractHeaderWithHttpInfo
     *
     * Grabs all JS from a PDF and returns a single JS file with all code
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractHeader'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function extractHeaderWithHttpInfo($file_input = null, $file_id = null, string $contentType = self::contentTypes['extractHeader'][0])
    {
        $request = $this->extractHeaderRequest($file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation extractHeaderAsync
     *
     * Grabs all JS from a PDF and returns a single JS file with all code
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractHeader'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractHeaderAsync($file_input = null, $file_id = null, string $contentType = self::contentTypes['extractHeader'][0])
    {
        return $this->extractHeaderAsyncWithHttpInfo($file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extractHeaderAsyncWithHttpInfo
     *
     * Grabs all JS from a PDF and returns a single JS file with all code
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractHeader'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractHeaderAsyncWithHttpInfo($file_input = null, $file_id = null, string $contentType = self::contentTypes['extractHeader'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->extractHeaderRequest($file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extractHeader'
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractHeader'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extractHeaderRequest($file_input = null, $file_id = null, string $contentType = self::contentTypes['extractHeader'][0])
    {




        $resourcePath = '/api/v1/misc/show-javascript';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extractHeader1
     *
     * Extract header from PDF file
     *
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $use_first_text_as_fallback Flag indicating whether to use the first text as a fallback if no suitable title is found. Defaults to false. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractHeader1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function extractHeader1($file_input = null, $file_id = null, $use_first_text_as_fallback = false, string $contentType = self::contentTypes['extractHeader1'][0])
    {
        list($response) = $this->extractHeader1WithHttpInfo($file_input, $file_id, $use_first_text_as_fallback, $contentType);
        return $response;
    }

    /**
     * Operation extractHeader1WithHttpInfo
     *
     * Extract header from PDF file
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $use_first_text_as_fallback Flag indicating whether to use the first text as a fallback if no suitable title is found. Defaults to false. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractHeader1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function extractHeader1WithHttpInfo($file_input = null, $file_id = null, $use_first_text_as_fallback = false, string $contentType = self::contentTypes['extractHeader1'][0])
    {
        $request = $this->extractHeader1Request($file_input, $file_id, $use_first_text_as_fallback, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'string',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'string',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation extractHeader1Async
     *
     * Extract header from PDF file
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $use_first_text_as_fallback Flag indicating whether to use the first text as a fallback if no suitable title is found. Defaults to false. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractHeader1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractHeader1Async($file_input = null, $file_id = null, $use_first_text_as_fallback = false, string $contentType = self::contentTypes['extractHeader1'][0])
    {
        return $this->extractHeader1AsyncWithHttpInfo($file_input, $file_id, $use_first_text_as_fallback, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extractHeader1AsyncWithHttpInfo
     *
     * Extract header from PDF file
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $use_first_text_as_fallback Flag indicating whether to use the first text as a fallback if no suitable title is found. Defaults to false. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractHeader1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractHeader1AsyncWithHttpInfo($file_input = null, $file_id = null, $use_first_text_as_fallback = false, string $contentType = self::contentTypes['extractHeader1'][0])
    {
        $returnType = 'string';
        $request = $this->extractHeader1Request($file_input, $file_id, $use_first_text_as_fallback, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extractHeader1'
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $use_first_text_as_fallback Flag indicating whether to use the first text as a fallback if no suitable title is found. Defaults to false. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractHeader1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extractHeader1Request($file_input = null, $file_id = null, $use_first_text_as_fallback = false, string $contentType = self::contentTypes['extractHeader1'][0])
    {





        $resourcePath = '/api/v1/misc/auto-rename';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'use_first_text_as_fallback' => $use_first_text_as_fallback,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extractImageScans
     *
     * Extract image scans from an input file
     *
     * @param  \SplFileObject $file_input file_input (required)
     * @param  int $angle_threshold The angle threshold for the image scan extraction (required)
     * @param  int $tolerance The tolerance for the image scan extraction (required)
     * @param  int $min_area The minimum area for the image scan extraction (required)
     * @param  int $min_contour_area The minimum contour area for the image scan extraction (required)
     * @param  int $border_size The border size for the image scan extraction (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractImageScans'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function extractImageScans($file_input, $angle_threshold, $tolerance, $min_area, $min_contour_area, $border_size, string $contentType = self::contentTypes['extractImageScans'][0])
    {
        list($response) = $this->extractImageScansWithHttpInfo($file_input, $angle_threshold, $tolerance, $min_area, $min_contour_area, $border_size, $contentType);
        return $response;
    }

    /**
     * Operation extractImageScansWithHttpInfo
     *
     * Extract image scans from an input file
     *
     * @param  \SplFileObject $file_input (required)
     * @param  int $angle_threshold The angle threshold for the image scan extraction (required)
     * @param  int $tolerance The tolerance for the image scan extraction (required)
     * @param  int $min_area The minimum area for the image scan extraction (required)
     * @param  int $min_contour_area The minimum contour area for the image scan extraction (required)
     * @param  int $border_size The border size for the image scan extraction (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractImageScans'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function extractImageScansWithHttpInfo($file_input, $angle_threshold, $tolerance, $min_area, $min_contour_area, $border_size, string $contentType = self::contentTypes['extractImageScans'][0])
    {
        $request = $this->extractImageScansRequest($file_input, $angle_threshold, $tolerance, $min_area, $min_contour_area, $border_size, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation extractImageScansAsync
     *
     * Extract image scans from an input file
     *
     * @param  \SplFileObject $file_input (required)
     * @param  int $angle_threshold The angle threshold for the image scan extraction (required)
     * @param  int $tolerance The tolerance for the image scan extraction (required)
     * @param  int $min_area The minimum area for the image scan extraction (required)
     * @param  int $min_contour_area The minimum contour area for the image scan extraction (required)
     * @param  int $border_size The border size for the image scan extraction (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractImageScans'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractImageScansAsync($file_input, $angle_threshold, $tolerance, $min_area, $min_contour_area, $border_size, string $contentType = self::contentTypes['extractImageScans'][0])
    {
        return $this->extractImageScansAsyncWithHttpInfo($file_input, $angle_threshold, $tolerance, $min_area, $min_contour_area, $border_size, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extractImageScansAsyncWithHttpInfo
     *
     * Extract image scans from an input file
     *
     * @param  \SplFileObject $file_input (required)
     * @param  int $angle_threshold The angle threshold for the image scan extraction (required)
     * @param  int $tolerance The tolerance for the image scan extraction (required)
     * @param  int $min_area The minimum area for the image scan extraction (required)
     * @param  int $min_contour_area The minimum contour area for the image scan extraction (required)
     * @param  int $border_size The border size for the image scan extraction (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractImageScans'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractImageScansAsyncWithHttpInfo($file_input, $angle_threshold, $tolerance, $min_area, $min_contour_area, $border_size, string $contentType = self::contentTypes['extractImageScans'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->extractImageScansRequest($file_input, $angle_threshold, $tolerance, $min_area, $min_contour_area, $border_size, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extractImageScans'
     *
     * @param  \SplFileObject $file_input (required)
     * @param  int $angle_threshold The angle threshold for the image scan extraction (required)
     * @param  int $tolerance The tolerance for the image scan extraction (required)
     * @param  int $min_area The minimum area for the image scan extraction (required)
     * @param  int $min_contour_area The minimum contour area for the image scan extraction (required)
     * @param  int $border_size The border size for the image scan extraction (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractImageScans'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extractImageScansRequest($file_input, $angle_threshold, $tolerance, $min_area, $min_contour_area, $border_size, string $contentType = self::contentTypes['extractImageScans'][0])
    {

        // verify the required parameter 'file_input' is set
        if ($file_input === null || (is_array($file_input) && count($file_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_input when calling extractImageScans'
            );
        }

        // verify the required parameter 'angle_threshold' is set
        if ($angle_threshold === null || (is_array($angle_threshold) && count($angle_threshold) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $angle_threshold when calling extractImageScans'
            );
        }

        // verify the required parameter 'tolerance' is set
        if ($tolerance === null || (is_array($tolerance) && count($tolerance) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tolerance when calling extractImageScans'
            );
        }

        // verify the required parameter 'min_area' is set
        if ($min_area === null || (is_array($min_area) && count($min_area) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $min_area when calling extractImageScans'
            );
        }

        // verify the required parameter 'min_contour_area' is set
        if ($min_contour_area === null || (is_array($min_contour_area) && count($min_contour_area) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $min_contour_area when calling extractImageScans'
            );
        }

        // verify the required parameter 'border_size' is set
        if ($border_size === null || (is_array($border_size) && count($border_size) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $border_size when calling extractImageScans'
            );
        }


        $resourcePath = '/api/v1/misc/extract-image-scans';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'angle_threshold' => $angle_threshold,
            'tolerance' => $tolerance,
            'min_area' => $min_area,
            'min_contour_area' => $min_contour_area,
            'border_size' => $border_size,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/zip', 'image/png', 'image/jpeg', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extractImages
     *
     * Extract images from a PDF file
     *
     * @param  string $format The output image format e.g., &#39;png&#39;, &#39;jpeg&#39;, or &#39;gif&#39; (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $allow_duplicates Boolean to enable/disable the saving of duplicate images, true to enable duplicates (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractImages'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function extractImages($format, $file_input = null, $file_id = null, $allow_duplicates = false, string $contentType = self::contentTypes['extractImages'][0])
    {
        list($response) = $this->extractImagesWithHttpInfo($format, $file_input, $file_id, $allow_duplicates, $contentType);
        return $response;
    }

    /**
     * Operation extractImagesWithHttpInfo
     *
     * Extract images from a PDF file
     *
     * @param  string $format The output image format e.g., &#39;png&#39;, &#39;jpeg&#39;, or &#39;gif&#39; (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $allow_duplicates Boolean to enable/disable the saving of duplicate images, true to enable duplicates (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractImages'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function extractImagesWithHttpInfo($format, $file_input = null, $file_id = null, $allow_duplicates = false, string $contentType = self::contentTypes['extractImages'][0])
    {
        $request = $this->extractImagesRequest($format, $file_input, $file_id, $allow_duplicates, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation extractImagesAsync
     *
     * Extract images from a PDF file
     *
     * @param  string $format The output image format e.g., &#39;png&#39;, &#39;jpeg&#39;, or &#39;gif&#39; (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $allow_duplicates Boolean to enable/disable the saving of duplicate images, true to enable duplicates (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractImages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractImagesAsync($format, $file_input = null, $file_id = null, $allow_duplicates = false, string $contentType = self::contentTypes['extractImages'][0])
    {
        return $this->extractImagesAsyncWithHttpInfo($format, $file_input, $file_id, $allow_duplicates, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extractImagesAsyncWithHttpInfo
     *
     * Extract images from a PDF file
     *
     * @param  string $format The output image format e.g., &#39;png&#39;, &#39;jpeg&#39;, or &#39;gif&#39; (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $allow_duplicates Boolean to enable/disable the saving of duplicate images, true to enable duplicates (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractImages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractImagesAsyncWithHttpInfo($format, $file_input = null, $file_id = null, $allow_duplicates = false, string $contentType = self::contentTypes['extractImages'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->extractImagesRequest($format, $file_input, $file_id, $allow_duplicates, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extractImages'
     *
     * @param  string $format The output image format e.g., &#39;png&#39;, &#39;jpeg&#39;, or &#39;gif&#39; (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $allow_duplicates Boolean to enable/disable the saving of duplicate images, true to enable duplicates (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractImages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extractImagesRequest($format, $file_input = null, $file_id = null, $allow_duplicates = false, string $contentType = self::contentTypes['extractImages'][0])
    {

        // verify the required parameter 'format' is set
        if ($format === null || (is_array($format) && count($format) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $format when calling extractImages'
            );
        }





        $resourcePath = '/api/v1/misc/extract-images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'format' => $format,
            'allow_duplicates' => $allow_duplicates,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/zip', 'image/png', 'image/jpeg', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation flatten
     *
     * Flatten PDF form fields or full page
     *
     * @param  bool $flatten_only_forms True to flatten only the forms, false to flatten full PDF (Convert page to image) (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['flatten'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function flatten($flatten_only_forms, $file_input = null, $file_id = null, string $contentType = self::contentTypes['flatten'][0])
    {
        list($response) = $this->flattenWithHttpInfo($flatten_only_forms, $file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation flattenWithHttpInfo
     *
     * Flatten PDF form fields or full page
     *
     * @param  bool $flatten_only_forms True to flatten only the forms, false to flatten full PDF (Convert page to image) (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['flatten'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function flattenWithHttpInfo($flatten_only_forms, $file_input = null, $file_id = null, string $contentType = self::contentTypes['flatten'][0])
    {
        $request = $this->flattenRequest($flatten_only_forms, $file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation flattenAsync
     *
     * Flatten PDF form fields or full page
     *
     * @param  bool $flatten_only_forms True to flatten only the forms, false to flatten full PDF (Convert page to image) (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['flatten'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function flattenAsync($flatten_only_forms, $file_input = null, $file_id = null, string $contentType = self::contentTypes['flatten'][0])
    {
        return $this->flattenAsyncWithHttpInfo($flatten_only_forms, $file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation flattenAsyncWithHttpInfo
     *
     * Flatten PDF form fields or full page
     *
     * @param  bool $flatten_only_forms True to flatten only the forms, false to flatten full PDF (Convert page to image) (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['flatten'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function flattenAsyncWithHttpInfo($flatten_only_forms, $file_input = null, $file_id = null, string $contentType = self::contentTypes['flatten'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->flattenRequest($flatten_only_forms, $file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'flatten'
     *
     * @param  bool $flatten_only_forms True to flatten only the forms, false to flatten full PDF (Convert page to image) (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['flatten'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function flattenRequest($flatten_only_forms, $file_input = null, $file_id = null, string $contentType = self::contentTypes['flatten'][0])
    {

        // verify the required parameter 'flatten_only_forms' is set
        if ($flatten_only_forms === null || (is_array($flatten_only_forms) && count($flatten_only_forms) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flatten_only_forms when calling flatten'
            );
        }




        $resourcePath = '/api/v1/misc/flatten';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'flatten_only_forms' => $flatten_only_forms,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation metadata
     *
     * Update metadata of a PDF file
     *
     * @param  bool $delete_all Delete all metadata if set to true (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $author The author of the document (optional, default to 'author')
     * @param  string|null $creation_date The creation date of the document (format: yyyy/MM/dd HH:mm:ss) (optional, default to '2023/10/01 12:00:00')
     * @param  string|null $creator The creator of the document (optional, default to 'creator')
     * @param  string|null $keywords The keywords for the document (optional, default to 'keywords')
     * @param  string|null $modification_date The modification date of the document (format: yyyy/MM/dd HH:mm:ss) (optional, default to '2023/10/01 12:00:00')
     * @param  string|null $producer The producer of the document (optional, default to 'producer')
     * @param  string|null $subject The subject of the document (optional, default to 'subject')
     * @param  string|null $title The title of the document (optional, default to 'title')
     * @param  string|null $trapped The trapped status of the document (optional, default to 'False')
     * @param  array<string,string>|null $all_request_params Map list of key and value of custom parameters. Note these must start with customKey and customValue if they are non-standard (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['metadata'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function metadata($delete_all, $file_input = null, $file_id = null, $author = 'author', $creation_date = '2023/10/01 12:00:00', $creator = 'creator', $keywords = 'keywords', $modification_date = '2023/10/01 12:00:00', $producer = 'producer', $subject = 'subject', $title = 'title', $trapped = 'False', $all_request_params = null, string $contentType = self::contentTypes['metadata'][0])
    {
        list($response) = $this->metadataWithHttpInfo($delete_all, $file_input, $file_id, $author, $creation_date, $creator, $keywords, $modification_date, $producer, $subject, $title, $trapped, $all_request_params, $contentType);
        return $response;
    }

    /**
     * Operation metadataWithHttpInfo
     *
     * Update metadata of a PDF file
     *
     * @param  bool $delete_all Delete all metadata if set to true (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $author The author of the document (optional, default to 'author')
     * @param  string|null $creation_date The creation date of the document (format: yyyy/MM/dd HH:mm:ss) (optional, default to '2023/10/01 12:00:00')
     * @param  string|null $creator The creator of the document (optional, default to 'creator')
     * @param  string|null $keywords The keywords for the document (optional, default to 'keywords')
     * @param  string|null $modification_date The modification date of the document (format: yyyy/MM/dd HH:mm:ss) (optional, default to '2023/10/01 12:00:00')
     * @param  string|null $producer The producer of the document (optional, default to 'producer')
     * @param  string|null $subject The subject of the document (optional, default to 'subject')
     * @param  string|null $title The title of the document (optional, default to 'title')
     * @param  string|null $trapped The trapped status of the document (optional, default to 'False')
     * @param  array<string,string>|null $all_request_params Map list of key and value of custom parameters. Note these must start with customKey and customValue if they are non-standard (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['metadata'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function metadataWithHttpInfo($delete_all, $file_input = null, $file_id = null, $author = 'author', $creation_date = '2023/10/01 12:00:00', $creator = 'creator', $keywords = 'keywords', $modification_date = '2023/10/01 12:00:00', $producer = 'producer', $subject = 'subject', $title = 'title', $trapped = 'False', $all_request_params = null, string $contentType = self::contentTypes['metadata'][0])
    {
        $request = $this->metadataRequest($delete_all, $file_input, $file_id, $author, $creation_date, $creator, $keywords, $modification_date, $producer, $subject, $title, $trapped, $all_request_params, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation metadataAsync
     *
     * Update metadata of a PDF file
     *
     * @param  bool $delete_all Delete all metadata if set to true (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $author The author of the document (optional, default to 'author')
     * @param  string|null $creation_date The creation date of the document (format: yyyy/MM/dd HH:mm:ss) (optional, default to '2023/10/01 12:00:00')
     * @param  string|null $creator The creator of the document (optional, default to 'creator')
     * @param  string|null $keywords The keywords for the document (optional, default to 'keywords')
     * @param  string|null $modification_date The modification date of the document (format: yyyy/MM/dd HH:mm:ss) (optional, default to '2023/10/01 12:00:00')
     * @param  string|null $producer The producer of the document (optional, default to 'producer')
     * @param  string|null $subject The subject of the document (optional, default to 'subject')
     * @param  string|null $title The title of the document (optional, default to 'title')
     * @param  string|null $trapped The trapped status of the document (optional, default to 'False')
     * @param  array<string,string>|null $all_request_params Map list of key and value of custom parameters. Note these must start with customKey and customValue if they are non-standard (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['metadata'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function metadataAsync($delete_all, $file_input = null, $file_id = null, $author = 'author', $creation_date = '2023/10/01 12:00:00', $creator = 'creator', $keywords = 'keywords', $modification_date = '2023/10/01 12:00:00', $producer = 'producer', $subject = 'subject', $title = 'title', $trapped = 'False', $all_request_params = null, string $contentType = self::contentTypes['metadata'][0])
    {
        return $this->metadataAsyncWithHttpInfo($delete_all, $file_input, $file_id, $author, $creation_date, $creator, $keywords, $modification_date, $producer, $subject, $title, $trapped, $all_request_params, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation metadataAsyncWithHttpInfo
     *
     * Update metadata of a PDF file
     *
     * @param  bool $delete_all Delete all metadata if set to true (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $author The author of the document (optional, default to 'author')
     * @param  string|null $creation_date The creation date of the document (format: yyyy/MM/dd HH:mm:ss) (optional, default to '2023/10/01 12:00:00')
     * @param  string|null $creator The creator of the document (optional, default to 'creator')
     * @param  string|null $keywords The keywords for the document (optional, default to 'keywords')
     * @param  string|null $modification_date The modification date of the document (format: yyyy/MM/dd HH:mm:ss) (optional, default to '2023/10/01 12:00:00')
     * @param  string|null $producer The producer of the document (optional, default to 'producer')
     * @param  string|null $subject The subject of the document (optional, default to 'subject')
     * @param  string|null $title The title of the document (optional, default to 'title')
     * @param  string|null $trapped The trapped status of the document (optional, default to 'False')
     * @param  array<string,string>|null $all_request_params Map list of key and value of custom parameters. Note these must start with customKey and customValue if they are non-standard (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['metadata'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function metadataAsyncWithHttpInfo($delete_all, $file_input = null, $file_id = null, $author = 'author', $creation_date = '2023/10/01 12:00:00', $creator = 'creator', $keywords = 'keywords', $modification_date = '2023/10/01 12:00:00', $producer = 'producer', $subject = 'subject', $title = 'title', $trapped = 'False', $all_request_params = null, string $contentType = self::contentTypes['metadata'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->metadataRequest($delete_all, $file_input, $file_id, $author, $creation_date, $creator, $keywords, $modification_date, $producer, $subject, $title, $trapped, $all_request_params, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'metadata'
     *
     * @param  bool $delete_all Delete all metadata if set to true (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $author The author of the document (optional, default to 'author')
     * @param  string|null $creation_date The creation date of the document (format: yyyy/MM/dd HH:mm:ss) (optional, default to '2023/10/01 12:00:00')
     * @param  string|null $creator The creator of the document (optional, default to 'creator')
     * @param  string|null $keywords The keywords for the document (optional, default to 'keywords')
     * @param  string|null $modification_date The modification date of the document (format: yyyy/MM/dd HH:mm:ss) (optional, default to '2023/10/01 12:00:00')
     * @param  string|null $producer The producer of the document (optional, default to 'producer')
     * @param  string|null $subject The subject of the document (optional, default to 'subject')
     * @param  string|null $title The title of the document (optional, default to 'title')
     * @param  string|null $trapped The trapped status of the document (optional, default to 'False')
     * @param  array<string,string>|null $all_request_params Map list of key and value of custom parameters. Note these must start with customKey and customValue if they are non-standard (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['metadata'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function metadataRequest($delete_all, $file_input = null, $file_id = null, $author = 'author', $creation_date = '2023/10/01 12:00:00', $creator = 'creator', $keywords = 'keywords', $modification_date = '2023/10/01 12:00:00', $producer = 'producer', $subject = 'subject', $title = 'title', $trapped = 'False', $all_request_params = null, string $contentType = self::contentTypes['metadata'][0])
    {

        // verify the required parameter 'delete_all' is set
        if ($delete_all === null || (is_array($delete_all) && count($delete_all) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $delete_all when calling metadata'
            );
        }




        if ($creation_date !== null && !preg_match("/yyyy\/MM\/dd HH:mm:ss/", $creation_date)) {
            throw new \InvalidArgumentException("invalid value for \"creation_date\" when calling MiscApi.metadata, must conform to the pattern /yyyy\/MM\/dd HH:mm:ss/.");
        }
        


        if ($modification_date !== null && !preg_match("/yyyy\/MM\/dd HH:mm:ss/", $modification_date)) {
            throw new \InvalidArgumentException("invalid value for \"modification_date\" when calling MiscApi.metadata, must conform to the pattern /yyyy\/MM\/dd HH:mm:ss/.");
        }
        






        $resourcePath = '/api/v1/misc/update-metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'delete_all' => $delete_all,
            'author' => $author,
            'creation_date' => $creation_date,
            'creator' => $creator,
            'keywords' => $keywords,
            'modification_date' => $modification_date,
            'producer' => $producer,
            'subject' => $subject,
            'title' => $title,
            'trapped' => $trapped,
            'all_request_params' => $all_request_params,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation optimizePdf
     *
     * Optimize PDF file
     *
     * @param  int $optimize_level The level of optimization to apply to the PDF file. Higher values indicate greater compression but may reduce quality. (required)
     * @param  string $expected_output_size The expected output size, e.g. &#39;100MB&#39;, &#39;25KB&#39;, etc. (required)
     * @param  bool $linearize Whether to linearize the PDF for faster web viewing. Default is false. (required)
     * @param  bool $normalize Whether to normalize the PDF content for better compatibility. Default is false. (required)
     * @param  bool $grayscale Whether to convert the PDF to grayscale. Default is false. (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['optimizePdf'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function optimizePdf($optimize_level, $expected_output_size, $linearize, $normalize, $grayscale, $file_input = null, $file_id = null, string $contentType = self::contentTypes['optimizePdf'][0])
    {
        list($response) = $this->optimizePdfWithHttpInfo($optimize_level, $expected_output_size, $linearize, $normalize, $grayscale, $file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation optimizePdfWithHttpInfo
     *
     * Optimize PDF file
     *
     * @param  int $optimize_level The level of optimization to apply to the PDF file. Higher values indicate greater compression but may reduce quality. (required)
     * @param  string $expected_output_size The expected output size, e.g. &#39;100MB&#39;, &#39;25KB&#39;, etc. (required)
     * @param  bool $linearize Whether to linearize the PDF for faster web viewing. Default is false. (required)
     * @param  bool $normalize Whether to normalize the PDF content for better compatibility. Default is false. (required)
     * @param  bool $grayscale Whether to convert the PDF to grayscale. Default is false. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['optimizePdf'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function optimizePdfWithHttpInfo($optimize_level, $expected_output_size, $linearize, $normalize, $grayscale, $file_input = null, $file_id = null, string $contentType = self::contentTypes['optimizePdf'][0])
    {
        $request = $this->optimizePdfRequest($optimize_level, $expected_output_size, $linearize, $normalize, $grayscale, $file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation optimizePdfAsync
     *
     * Optimize PDF file
     *
     * @param  int $optimize_level The level of optimization to apply to the PDF file. Higher values indicate greater compression but may reduce quality. (required)
     * @param  string $expected_output_size The expected output size, e.g. &#39;100MB&#39;, &#39;25KB&#39;, etc. (required)
     * @param  bool $linearize Whether to linearize the PDF for faster web viewing. Default is false. (required)
     * @param  bool $normalize Whether to normalize the PDF content for better compatibility. Default is false. (required)
     * @param  bool $grayscale Whether to convert the PDF to grayscale. Default is false. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['optimizePdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function optimizePdfAsync($optimize_level, $expected_output_size, $linearize, $normalize, $grayscale, $file_input = null, $file_id = null, string $contentType = self::contentTypes['optimizePdf'][0])
    {
        return $this->optimizePdfAsyncWithHttpInfo($optimize_level, $expected_output_size, $linearize, $normalize, $grayscale, $file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation optimizePdfAsyncWithHttpInfo
     *
     * Optimize PDF file
     *
     * @param  int $optimize_level The level of optimization to apply to the PDF file. Higher values indicate greater compression but may reduce quality. (required)
     * @param  string $expected_output_size The expected output size, e.g. &#39;100MB&#39;, &#39;25KB&#39;, etc. (required)
     * @param  bool $linearize Whether to linearize the PDF for faster web viewing. Default is false. (required)
     * @param  bool $normalize Whether to normalize the PDF content for better compatibility. Default is false. (required)
     * @param  bool $grayscale Whether to convert the PDF to grayscale. Default is false. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['optimizePdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function optimizePdfAsyncWithHttpInfo($optimize_level, $expected_output_size, $linearize, $normalize, $grayscale, $file_input = null, $file_id = null, string $contentType = self::contentTypes['optimizePdf'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->optimizePdfRequest($optimize_level, $expected_output_size, $linearize, $normalize, $grayscale, $file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'optimizePdf'
     *
     * @param  int $optimize_level The level of optimization to apply to the PDF file. Higher values indicate greater compression but may reduce quality. (required)
     * @param  string $expected_output_size The expected output size, e.g. &#39;100MB&#39;, &#39;25KB&#39;, etc. (required)
     * @param  bool $linearize Whether to linearize the PDF for faster web viewing. Default is false. (required)
     * @param  bool $normalize Whether to normalize the PDF content for better compatibility. Default is false. (required)
     * @param  bool $grayscale Whether to convert the PDF to grayscale. Default is false. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['optimizePdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function optimizePdfRequest($optimize_level, $expected_output_size, $linearize, $normalize, $grayscale, $file_input = null, $file_id = null, string $contentType = self::contentTypes['optimizePdf'][0])
    {

        // verify the required parameter 'optimize_level' is set
        if ($optimize_level === null || (is_array($optimize_level) && count($optimize_level) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $optimize_level when calling optimizePdf'
            );
        }

        // verify the required parameter 'expected_output_size' is set
        if ($expected_output_size === null || (is_array($expected_output_size) && count($expected_output_size) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $expected_output_size when calling optimizePdf'
            );
        }

        // verify the required parameter 'linearize' is set
        if ($linearize === null || (is_array($linearize) && count($linearize) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $linearize when calling optimizePdf'
            );
        }

        // verify the required parameter 'normalize' is set
        if ($normalize === null || (is_array($normalize) && count($normalize) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $normalize when calling optimizePdf'
            );
        }

        // verify the required parameter 'grayscale' is set
        if ($grayscale === null || (is_array($grayscale) && count($grayscale) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $grayscale when calling optimizePdf'
            );
        }




        $resourcePath = '/api/v1/misc/compress-pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'optimize_level' => $optimize_level,
            'expected_output_size' => $expected_output_size,
            'linearize' => $linearize,
            'normalize' => $normalize,
            'grayscale' => $grayscale,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation overlayImage
     *
     * Overlay image onto a PDF file
     *
     * @param  \SplFileObject $image_file image_file (required)
     * @param  float $x The x-coordinate at which to place the top-left corner of the image. (required)
     * @param  float $y The y-coordinate at which to place the top-left corner of the image. (required)
     * @param  bool $every_page Whether to overlay the image onto every page of the PDF. (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['overlayImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function overlayImage($image_file, $x, $y, $every_page, $file_input = null, $file_id = null, string $contentType = self::contentTypes['overlayImage'][0])
    {
        list($response) = $this->overlayImageWithHttpInfo($image_file, $x, $y, $every_page, $file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation overlayImageWithHttpInfo
     *
     * Overlay image onto a PDF file
     *
     * @param  \SplFileObject $image_file (required)
     * @param  float $x The x-coordinate at which to place the top-left corner of the image. (required)
     * @param  float $y The y-coordinate at which to place the top-left corner of the image. (required)
     * @param  bool $every_page Whether to overlay the image onto every page of the PDF. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['overlayImage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function overlayImageWithHttpInfo($image_file, $x, $y, $every_page, $file_input = null, $file_id = null, string $contentType = self::contentTypes['overlayImage'][0])
    {
        $request = $this->overlayImageRequest($image_file, $x, $y, $every_page, $file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'string',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'string',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation overlayImageAsync
     *
     * Overlay image onto a PDF file
     *
     * @param  \SplFileObject $image_file (required)
     * @param  float $x The x-coordinate at which to place the top-left corner of the image. (required)
     * @param  float $y The y-coordinate at which to place the top-left corner of the image. (required)
     * @param  bool $every_page Whether to overlay the image onto every page of the PDF. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['overlayImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function overlayImageAsync($image_file, $x, $y, $every_page, $file_input = null, $file_id = null, string $contentType = self::contentTypes['overlayImage'][0])
    {
        return $this->overlayImageAsyncWithHttpInfo($image_file, $x, $y, $every_page, $file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation overlayImageAsyncWithHttpInfo
     *
     * Overlay image onto a PDF file
     *
     * @param  \SplFileObject $image_file (required)
     * @param  float $x The x-coordinate at which to place the top-left corner of the image. (required)
     * @param  float $y The y-coordinate at which to place the top-left corner of the image. (required)
     * @param  bool $every_page Whether to overlay the image onto every page of the PDF. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['overlayImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function overlayImageAsyncWithHttpInfo($image_file, $x, $y, $every_page, $file_input = null, $file_id = null, string $contentType = self::contentTypes['overlayImage'][0])
    {
        $returnType = 'string';
        $request = $this->overlayImageRequest($image_file, $x, $y, $every_page, $file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'overlayImage'
     *
     * @param  \SplFileObject $image_file (required)
     * @param  float $x The x-coordinate at which to place the top-left corner of the image. (required)
     * @param  float $y The y-coordinate at which to place the top-left corner of the image. (required)
     * @param  bool $every_page Whether to overlay the image onto every page of the PDF. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['overlayImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function overlayImageRequest($image_file, $x, $y, $every_page, $file_input = null, $file_id = null, string $contentType = self::contentTypes['overlayImage'][0])
    {

        // verify the required parameter 'image_file' is set
        if ($image_file === null || (is_array($image_file) && count($image_file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_file when calling overlayImage'
            );
        }

        // verify the required parameter 'x' is set
        if ($x === null || (is_array($x) && count($x) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x when calling overlayImage'
            );
        }

        // verify the required parameter 'y' is set
        if ($y === null || (is_array($y) && count($y) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $y when calling overlayImage'
            );
        }

        // verify the required parameter 'every_page' is set
        if ($every_page === null || (is_array($every_page) && count($every_page) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $every_page when calling overlayImage'
            );
        }




        $resourcePath = '/api/v1/misc/add-image';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'image_file' => $image_file,
            'x' => $x,
            'y' => $y,
            'every_page' => $every_page,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation processPdfWithOCR
     *
     * Process a PDF file with OCR
     *
     * @param  string[] $languages List of languages to use in OCR processing, e.g., &#39;eng&#39;, &#39;deu&#39; (required)
     * @param  string $ocr_type Specify the OCR type, e.g., &#39;skip-text&#39;, &#39;force-ocr&#39;, or &#39;Normal&#39; (required)
     * @param  string $ocr_render_type Specify the OCR render type, either &#39;hocr&#39; or &#39;sandwich&#39; (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $sidecar Include OCR text in a sidecar text file if set to true (optional)
     * @param  bool|null $deskew Deskew the input file if set to true (optional)
     * @param  bool|null $clean Clean the input file if set to true (optional)
     * @param  bool|null $clean_final Clean the final output if set to true (optional)
     * @param  bool|null $remove_images_after Remove images from the output PDF if set to true (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processPdfWithOCR'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function processPdfWithOCR($languages, $ocr_type, $ocr_render_type, $file_input = null, $file_id = null, $sidecar = null, $deskew = null, $clean = null, $clean_final = null, $remove_images_after = null, string $contentType = self::contentTypes['processPdfWithOCR'][0])
    {
        list($response) = $this->processPdfWithOCRWithHttpInfo($languages, $ocr_type, $ocr_render_type, $file_input, $file_id, $sidecar, $deskew, $clean, $clean_final, $remove_images_after, $contentType);
        return $response;
    }

    /**
     * Operation processPdfWithOCRWithHttpInfo
     *
     * Process a PDF file with OCR
     *
     * @param  string[] $languages List of languages to use in OCR processing, e.g., &#39;eng&#39;, &#39;deu&#39; (required)
     * @param  string $ocr_type Specify the OCR type, e.g., &#39;skip-text&#39;, &#39;force-ocr&#39;, or &#39;Normal&#39; (required)
     * @param  string $ocr_render_type Specify the OCR render type, either &#39;hocr&#39; or &#39;sandwich&#39; (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $sidecar Include OCR text in a sidecar text file if set to true (optional)
     * @param  bool|null $deskew Deskew the input file if set to true (optional)
     * @param  bool|null $clean Clean the input file if set to true (optional)
     * @param  bool|null $clean_final Clean the final output if set to true (optional)
     * @param  bool|null $remove_images_after Remove images from the output PDF if set to true (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processPdfWithOCR'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function processPdfWithOCRWithHttpInfo($languages, $ocr_type, $ocr_render_type, $file_input = null, $file_id = null, $sidecar = null, $deskew = null, $clean = null, $clean_final = null, $remove_images_after = null, string $contentType = self::contentTypes['processPdfWithOCR'][0])
    {
        $request = $this->processPdfWithOCRRequest($languages, $ocr_type, $ocr_render_type, $file_input, $file_id, $sidecar, $deskew, $clean, $clean_final, $remove_images_after, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation processPdfWithOCRAsync
     *
     * Process a PDF file with OCR
     *
     * @param  string[] $languages List of languages to use in OCR processing, e.g., &#39;eng&#39;, &#39;deu&#39; (required)
     * @param  string $ocr_type Specify the OCR type, e.g., &#39;skip-text&#39;, &#39;force-ocr&#39;, or &#39;Normal&#39; (required)
     * @param  string $ocr_render_type Specify the OCR render type, either &#39;hocr&#39; or &#39;sandwich&#39; (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $sidecar Include OCR text in a sidecar text file if set to true (optional)
     * @param  bool|null $deskew Deskew the input file if set to true (optional)
     * @param  bool|null $clean Clean the input file if set to true (optional)
     * @param  bool|null $clean_final Clean the final output if set to true (optional)
     * @param  bool|null $remove_images_after Remove images from the output PDF if set to true (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processPdfWithOCR'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function processPdfWithOCRAsync($languages, $ocr_type, $ocr_render_type, $file_input = null, $file_id = null, $sidecar = null, $deskew = null, $clean = null, $clean_final = null, $remove_images_after = null, string $contentType = self::contentTypes['processPdfWithOCR'][0])
    {
        return $this->processPdfWithOCRAsyncWithHttpInfo($languages, $ocr_type, $ocr_render_type, $file_input, $file_id, $sidecar, $deskew, $clean, $clean_final, $remove_images_after, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation processPdfWithOCRAsyncWithHttpInfo
     *
     * Process a PDF file with OCR
     *
     * @param  string[] $languages List of languages to use in OCR processing, e.g., &#39;eng&#39;, &#39;deu&#39; (required)
     * @param  string $ocr_type Specify the OCR type, e.g., &#39;skip-text&#39;, &#39;force-ocr&#39;, or &#39;Normal&#39; (required)
     * @param  string $ocr_render_type Specify the OCR render type, either &#39;hocr&#39; or &#39;sandwich&#39; (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $sidecar Include OCR text in a sidecar text file if set to true (optional)
     * @param  bool|null $deskew Deskew the input file if set to true (optional)
     * @param  bool|null $clean Clean the input file if set to true (optional)
     * @param  bool|null $clean_final Clean the final output if set to true (optional)
     * @param  bool|null $remove_images_after Remove images from the output PDF if set to true (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processPdfWithOCR'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function processPdfWithOCRAsyncWithHttpInfo($languages, $ocr_type, $ocr_render_type, $file_input = null, $file_id = null, $sidecar = null, $deskew = null, $clean = null, $clean_final = null, $remove_images_after = null, string $contentType = self::contentTypes['processPdfWithOCR'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->processPdfWithOCRRequest($languages, $ocr_type, $ocr_render_type, $file_input, $file_id, $sidecar, $deskew, $clean, $clean_final, $remove_images_after, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'processPdfWithOCR'
     *
     * @param  string[] $languages List of languages to use in OCR processing, e.g., &#39;eng&#39;, &#39;deu&#39; (required)
     * @param  string $ocr_type Specify the OCR type, e.g., &#39;skip-text&#39;, &#39;force-ocr&#39;, or &#39;Normal&#39; (required)
     * @param  string $ocr_render_type Specify the OCR render type, either &#39;hocr&#39; or &#39;sandwich&#39; (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $sidecar Include OCR text in a sidecar text file if set to true (optional)
     * @param  bool|null $deskew Deskew the input file if set to true (optional)
     * @param  bool|null $clean Clean the input file if set to true (optional)
     * @param  bool|null $clean_final Clean the final output if set to true (optional)
     * @param  bool|null $remove_images_after Remove images from the output PDF if set to true (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processPdfWithOCR'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function processPdfWithOCRRequest($languages, $ocr_type, $ocr_render_type, $file_input = null, $file_id = null, $sidecar = null, $deskew = null, $clean = null, $clean_final = null, $remove_images_after = null, string $contentType = self::contentTypes['processPdfWithOCR'][0])
    {

        // verify the required parameter 'languages' is set
        if ($languages === null || (is_array($languages) && count($languages) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $languages when calling processPdfWithOCR'
            );
        }

        // verify the required parameter 'ocr_type' is set
        if ($ocr_type === null || (is_array($ocr_type) && count($ocr_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocr_type when calling processPdfWithOCR'
            );
        }

        // verify the required parameter 'ocr_render_type' is set
        if ($ocr_render_type === null || (is_array($ocr_render_type) && count($ocr_render_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ocr_render_type when calling processPdfWithOCR'
            );
        }









        $resourcePath = '/api/v1/misc/ocr-pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'languages' => $languages,
            'sidecar' => $sidecar,
            'deskew' => $deskew,
            'clean' => $clean,
            'clean_final' => $clean_final,
            'ocr_type' => $ocr_type,
            'ocr_render_type' => $ocr_render_type,
            'remove_images_after' => $remove_images_after,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeBlankPages
     *
     * Remove blank pages from a PDF file
     *
     * @param  int $threshold The threshold value to determine blank pages (required)
     * @param  float $white_percent The percentage of white color on a page to consider it as blank (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeBlankPages'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function removeBlankPages($threshold, $white_percent, $file_input = null, $file_id = null, string $contentType = self::contentTypes['removeBlankPages'][0])
    {
        list($response) = $this->removeBlankPagesWithHttpInfo($threshold, $white_percent, $file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation removeBlankPagesWithHttpInfo
     *
     * Remove blank pages from a PDF file
     *
     * @param  int $threshold The threshold value to determine blank pages (required)
     * @param  float $white_percent The percentage of white color on a page to consider it as blank (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeBlankPages'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeBlankPagesWithHttpInfo($threshold, $white_percent, $file_input = null, $file_id = null, string $contentType = self::contentTypes['removeBlankPages'][0])
    {
        $request = $this->removeBlankPagesRequest($threshold, $white_percent, $file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'string',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'string',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation removeBlankPagesAsync
     *
     * Remove blank pages from a PDF file
     *
     * @param  int $threshold The threshold value to determine blank pages (required)
     * @param  float $white_percent The percentage of white color on a page to consider it as blank (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeBlankPages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeBlankPagesAsync($threshold, $white_percent, $file_input = null, $file_id = null, string $contentType = self::contentTypes['removeBlankPages'][0])
    {
        return $this->removeBlankPagesAsyncWithHttpInfo($threshold, $white_percent, $file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeBlankPagesAsyncWithHttpInfo
     *
     * Remove blank pages from a PDF file
     *
     * @param  int $threshold The threshold value to determine blank pages (required)
     * @param  float $white_percent The percentage of white color on a page to consider it as blank (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeBlankPages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeBlankPagesAsyncWithHttpInfo($threshold, $white_percent, $file_input = null, $file_id = null, string $contentType = self::contentTypes['removeBlankPages'][0])
    {
        $returnType = 'string';
        $request = $this->removeBlankPagesRequest($threshold, $white_percent, $file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeBlankPages'
     *
     * @param  int $threshold The threshold value to determine blank pages (required)
     * @param  float $white_percent The percentage of white color on a page to consider it as blank (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeBlankPages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function removeBlankPagesRequest($threshold, $white_percent, $file_input = null, $file_id = null, string $contentType = self::contentTypes['removeBlankPages'][0])
    {

        // verify the required parameter 'threshold' is set
        if ($threshold === null || (is_array($threshold) && count($threshold) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $threshold when calling removeBlankPages'
            );
        }
        if ($threshold > 255) {
            throw new \InvalidArgumentException('invalid value for "$threshold" when calling MiscApi.removeBlankPages, must be smaller than or equal to 255.');
        }
        if ($threshold < 0) {
            throw new \InvalidArgumentException('invalid value for "$threshold" when calling MiscApi.removeBlankPages, must be bigger than or equal to 0.');
        }
        
        // verify the required parameter 'white_percent' is set
        if ($white_percent === null || (is_array($white_percent) && count($white_percent) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $white_percent when calling removeBlankPages'
            );
        }
        if ($white_percent > 100) {
            throw new \InvalidArgumentException('invalid value for "$white_percent" when calling MiscApi.removeBlankPages, must be smaller than or equal to 100.');
        }
        if ($white_percent < 0.1) {
            throw new \InvalidArgumentException('invalid value for "$white_percent" when calling MiscApi.removeBlankPages, must be bigger than or equal to 0.1.');
        }
        



        $resourcePath = '/api/v1/misc/remove-blanks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'threshold' => $threshold,
            'white_percent' => $white_percent,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation repairPdf
     *
     * Repair a PDF file
     *
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['repairPdf'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function repairPdf($file_input = null, $file_id = null, string $contentType = self::contentTypes['repairPdf'][0])
    {
        list($response) = $this->repairPdfWithHttpInfo($file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation repairPdfWithHttpInfo
     *
     * Repair a PDF file
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['repairPdf'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function repairPdfWithHttpInfo($file_input = null, $file_id = null, string $contentType = self::contentTypes['repairPdf'][0])
    {
        $request = $this->repairPdfRequest($file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation repairPdfAsync
     *
     * Repair a PDF file
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['repairPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function repairPdfAsync($file_input = null, $file_id = null, string $contentType = self::contentTypes['repairPdf'][0])
    {
        return $this->repairPdfAsyncWithHttpInfo($file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation repairPdfAsyncWithHttpInfo
     *
     * Repair a PDF file
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['repairPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function repairPdfAsyncWithHttpInfo($file_input = null, $file_id = null, string $contentType = self::contentTypes['repairPdf'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->repairPdfRequest($file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'repairPdf'
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['repairPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function repairPdfRequest($file_input = null, $file_id = null, string $contentType = self::contentTypes['repairPdf'][0])
    {




        $resourcePath = '/api/v1/misc/repair';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceAndInvertColor
     *
     * Replace-Invert Color PDF
     *
     * @param  string $replace_and_invert_option Replace and Invert color options of a pdf. (required)
     * @param  string $high_contrast_color_combination If HIGH_CONTRAST_COLOR option selected, then pick the default color option for text and background. (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $back_ground_color If CUSTOM_COLOR option selected, then pick the custom color for background. Expected color value should be 24bit decimal value of a color (optional)
     * @param  string|null $text_color If CUSTOM_COLOR option selected, then pick the custom color for text. Expected color value should be 24bit decimal value of a color (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceAndInvertColor'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function replaceAndInvertColor($replace_and_invert_option, $high_contrast_color_combination, $file_input = null, $file_id = null, $back_ground_color = null, $text_color = null, string $contentType = self::contentTypes['replaceAndInvertColor'][0])
    {
        list($response) = $this->replaceAndInvertColorWithHttpInfo($replace_and_invert_option, $high_contrast_color_combination, $file_input, $file_id, $back_ground_color, $text_color, $contentType);
        return $response;
    }

    /**
     * Operation replaceAndInvertColorWithHttpInfo
     *
     * Replace-Invert Color PDF
     *
     * @param  string $replace_and_invert_option Replace and Invert color options of a pdf. (required)
     * @param  string $high_contrast_color_combination If HIGH_CONTRAST_COLOR option selected, then pick the default color option for text and background. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $back_ground_color If CUSTOM_COLOR option selected, then pick the custom color for background. Expected color value should be 24bit decimal value of a color (optional)
     * @param  string|null $text_color If CUSTOM_COLOR option selected, then pick the custom color for text. Expected color value should be 24bit decimal value of a color (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceAndInvertColor'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceAndInvertColorWithHttpInfo($replace_and_invert_option, $high_contrast_color_combination, $file_input = null, $file_id = null, $back_ground_color = null, $text_color = null, string $contentType = self::contentTypes['replaceAndInvertColor'][0])
    {
        $request = $this->replaceAndInvertColorRequest($replace_and_invert_option, $high_contrast_color_combination, $file_input, $file_id, $back_ground_color, $text_color, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation replaceAndInvertColorAsync
     *
     * Replace-Invert Color PDF
     *
     * @param  string $replace_and_invert_option Replace and Invert color options of a pdf. (required)
     * @param  string $high_contrast_color_combination If HIGH_CONTRAST_COLOR option selected, then pick the default color option for text and background. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $back_ground_color If CUSTOM_COLOR option selected, then pick the custom color for background. Expected color value should be 24bit decimal value of a color (optional)
     * @param  string|null $text_color If CUSTOM_COLOR option selected, then pick the custom color for text. Expected color value should be 24bit decimal value of a color (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceAndInvertColor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAndInvertColorAsync($replace_and_invert_option, $high_contrast_color_combination, $file_input = null, $file_id = null, $back_ground_color = null, $text_color = null, string $contentType = self::contentTypes['replaceAndInvertColor'][0])
    {
        return $this->replaceAndInvertColorAsyncWithHttpInfo($replace_and_invert_option, $high_contrast_color_combination, $file_input, $file_id, $back_ground_color, $text_color, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceAndInvertColorAsyncWithHttpInfo
     *
     * Replace-Invert Color PDF
     *
     * @param  string $replace_and_invert_option Replace and Invert color options of a pdf. (required)
     * @param  string $high_contrast_color_combination If HIGH_CONTRAST_COLOR option selected, then pick the default color option for text and background. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $back_ground_color If CUSTOM_COLOR option selected, then pick the custom color for background. Expected color value should be 24bit decimal value of a color (optional)
     * @param  string|null $text_color If CUSTOM_COLOR option selected, then pick the custom color for text. Expected color value should be 24bit decimal value of a color (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceAndInvertColor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAndInvertColorAsyncWithHttpInfo($replace_and_invert_option, $high_contrast_color_combination, $file_input = null, $file_id = null, $back_ground_color = null, $text_color = null, string $contentType = self::contentTypes['replaceAndInvertColor'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->replaceAndInvertColorRequest($replace_and_invert_option, $high_contrast_color_combination, $file_input, $file_id, $back_ground_color, $text_color, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceAndInvertColor'
     *
     * @param  string $replace_and_invert_option Replace and Invert color options of a pdf. (required)
     * @param  string $high_contrast_color_combination If HIGH_CONTRAST_COLOR option selected, then pick the default color option for text and background. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $back_ground_color If CUSTOM_COLOR option selected, then pick the custom color for background. Expected color value should be 24bit decimal value of a color (optional)
     * @param  string|null $text_color If CUSTOM_COLOR option selected, then pick the custom color for text. Expected color value should be 24bit decimal value of a color (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceAndInvertColor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function replaceAndInvertColorRequest($replace_and_invert_option, $high_contrast_color_combination, $file_input = null, $file_id = null, $back_ground_color = null, $text_color = null, string $contentType = self::contentTypes['replaceAndInvertColor'][0])
    {

        // verify the required parameter 'replace_and_invert_option' is set
        if ($replace_and_invert_option === null || (is_array($replace_and_invert_option) && count($replace_and_invert_option) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $replace_and_invert_option when calling replaceAndInvertColor'
            );
        }

        // verify the required parameter 'high_contrast_color_combination' is set
        if ($high_contrast_color_combination === null || (is_array($high_contrast_color_combination) && count($high_contrast_color_combination) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $high_contrast_color_combination when calling replaceAndInvertColor'
            );
        }






        $resourcePath = '/api/v1/misc/replace-invert-pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'replace_and_invert_option' => $replace_and_invert_option,
            'high_contrast_color_combination' => $high_contrast_color_combination,
            'back_ground_color' => $back_ground_color,
            'text_color' => $text_color,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scannerEffect
     *
     * Apply scanner effect to PDF
     *
     * @param  \SplFileObject $file_input file_input (required)
     * @param  string $quality Scan quality preset (required)
     * @param  string $rotation Rotation preset (required)
     * @param  string|null $colorspace Colorspace for output image (optional)
     * @param  int|null $border Border thickness in pixels (optional)
     * @param  int|null $rotate Base rotation in degrees (optional)
     * @param  int|null $rotate_variance Random rotation variance in degrees (optional)
     * @param  float|null $brightness Brightness multiplier (1.0 &#x3D; no change) (optional)
     * @param  float|null $contrast Contrast multiplier (1.0 &#x3D; no change) (optional)
     * @param  float|null $blur Blur amount (0 &#x3D; none, higher &#x3D; more blur) (optional)
     * @param  float|null $noise Noise amount (0 &#x3D; none, higher &#x3D; more noise) (optional)
     * @param  bool|null $yellowish Simulate yellowed paper (optional)
     * @param  int|null $resolution Rendering resolution in DPI (optional)
     * @param  bool|null $advanced_enabled Whether advanced settings are enabled (optional)
     * @param  int|null $quality_value quality_value (optional)
     * @param  int|null $rotation_value rotation_value (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scannerEffect'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function scannerEffect($file_input, $quality, $rotation, $colorspace = null, $border = null, $rotate = null, $rotate_variance = null, $brightness = null, $contrast = null, $blur = null, $noise = null, $yellowish = null, $resolution = null, $advanced_enabled = null, $quality_value = null, $rotation_value = null, string $contentType = self::contentTypes['scannerEffect'][0])
    {
        list($response) = $this->scannerEffectWithHttpInfo($file_input, $quality, $rotation, $colorspace, $border, $rotate, $rotate_variance, $brightness, $contrast, $blur, $noise, $yellowish, $resolution, $advanced_enabled, $quality_value, $rotation_value, $contentType);
        return $response;
    }

    /**
     * Operation scannerEffectWithHttpInfo
     *
     * Apply scanner effect to PDF
     *
     * @param  \SplFileObject $file_input (required)
     * @param  string $quality Scan quality preset (required)
     * @param  string $rotation Rotation preset (required)
     * @param  string|null $colorspace Colorspace for output image (optional)
     * @param  int|null $border Border thickness in pixels (optional)
     * @param  int|null $rotate Base rotation in degrees (optional)
     * @param  int|null $rotate_variance Random rotation variance in degrees (optional)
     * @param  float|null $brightness Brightness multiplier (1.0 &#x3D; no change) (optional)
     * @param  float|null $contrast Contrast multiplier (1.0 &#x3D; no change) (optional)
     * @param  float|null $blur Blur amount (0 &#x3D; none, higher &#x3D; more blur) (optional)
     * @param  float|null $noise Noise amount (0 &#x3D; none, higher &#x3D; more noise) (optional)
     * @param  bool|null $yellowish Simulate yellowed paper (optional)
     * @param  int|null $resolution Rendering resolution in DPI (optional)
     * @param  bool|null $advanced_enabled Whether advanced settings are enabled (optional)
     * @param  int|null $quality_value (optional)
     * @param  int|null $rotation_value (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scannerEffect'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function scannerEffectWithHttpInfo($file_input, $quality, $rotation, $colorspace = null, $border = null, $rotate = null, $rotate_variance = null, $brightness = null, $contrast = null, $blur = null, $noise = null, $yellowish = null, $resolution = null, $advanced_enabled = null, $quality_value = null, $rotation_value = null, string $contentType = self::contentTypes['scannerEffect'][0])
    {
        $request = $this->scannerEffectRequest($file_input, $quality, $rotation, $colorspace, $border, $rotate, $rotate_variance, $brightness, $contrast, $blur, $noise, $yellowish, $resolution, $advanced_enabled, $quality_value, $rotation_value, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'string',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'string',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation scannerEffectAsync
     *
     * Apply scanner effect to PDF
     *
     * @param  \SplFileObject $file_input (required)
     * @param  string $quality Scan quality preset (required)
     * @param  string $rotation Rotation preset (required)
     * @param  string|null $colorspace Colorspace for output image (optional)
     * @param  int|null $border Border thickness in pixels (optional)
     * @param  int|null $rotate Base rotation in degrees (optional)
     * @param  int|null $rotate_variance Random rotation variance in degrees (optional)
     * @param  float|null $brightness Brightness multiplier (1.0 &#x3D; no change) (optional)
     * @param  float|null $contrast Contrast multiplier (1.0 &#x3D; no change) (optional)
     * @param  float|null $blur Blur amount (0 &#x3D; none, higher &#x3D; more blur) (optional)
     * @param  float|null $noise Noise amount (0 &#x3D; none, higher &#x3D; more noise) (optional)
     * @param  bool|null $yellowish Simulate yellowed paper (optional)
     * @param  int|null $resolution Rendering resolution in DPI (optional)
     * @param  bool|null $advanced_enabled Whether advanced settings are enabled (optional)
     * @param  int|null $quality_value (optional)
     * @param  int|null $rotation_value (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scannerEffect'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scannerEffectAsync($file_input, $quality, $rotation, $colorspace = null, $border = null, $rotate = null, $rotate_variance = null, $brightness = null, $contrast = null, $blur = null, $noise = null, $yellowish = null, $resolution = null, $advanced_enabled = null, $quality_value = null, $rotation_value = null, string $contentType = self::contentTypes['scannerEffect'][0])
    {
        return $this->scannerEffectAsyncWithHttpInfo($file_input, $quality, $rotation, $colorspace, $border, $rotate, $rotate_variance, $brightness, $contrast, $blur, $noise, $yellowish, $resolution, $advanced_enabled, $quality_value, $rotation_value, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scannerEffectAsyncWithHttpInfo
     *
     * Apply scanner effect to PDF
     *
     * @param  \SplFileObject $file_input (required)
     * @param  string $quality Scan quality preset (required)
     * @param  string $rotation Rotation preset (required)
     * @param  string|null $colorspace Colorspace for output image (optional)
     * @param  int|null $border Border thickness in pixels (optional)
     * @param  int|null $rotate Base rotation in degrees (optional)
     * @param  int|null $rotate_variance Random rotation variance in degrees (optional)
     * @param  float|null $brightness Brightness multiplier (1.0 &#x3D; no change) (optional)
     * @param  float|null $contrast Contrast multiplier (1.0 &#x3D; no change) (optional)
     * @param  float|null $blur Blur amount (0 &#x3D; none, higher &#x3D; more blur) (optional)
     * @param  float|null $noise Noise amount (0 &#x3D; none, higher &#x3D; more noise) (optional)
     * @param  bool|null $yellowish Simulate yellowed paper (optional)
     * @param  int|null $resolution Rendering resolution in DPI (optional)
     * @param  bool|null $advanced_enabled Whether advanced settings are enabled (optional)
     * @param  int|null $quality_value (optional)
     * @param  int|null $rotation_value (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scannerEffect'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scannerEffectAsyncWithHttpInfo($file_input, $quality, $rotation, $colorspace = null, $border = null, $rotate = null, $rotate_variance = null, $brightness = null, $contrast = null, $blur = null, $noise = null, $yellowish = null, $resolution = null, $advanced_enabled = null, $quality_value = null, $rotation_value = null, string $contentType = self::contentTypes['scannerEffect'][0])
    {
        $returnType = 'string';
        $request = $this->scannerEffectRequest($file_input, $quality, $rotation, $colorspace, $border, $rotate, $rotate_variance, $brightness, $contrast, $blur, $noise, $yellowish, $resolution, $advanced_enabled, $quality_value, $rotation_value, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scannerEffect'
     *
     * @param  \SplFileObject $file_input (required)
     * @param  string $quality Scan quality preset (required)
     * @param  string $rotation Rotation preset (required)
     * @param  string|null $colorspace Colorspace for output image (optional)
     * @param  int|null $border Border thickness in pixels (optional)
     * @param  int|null $rotate Base rotation in degrees (optional)
     * @param  int|null $rotate_variance Random rotation variance in degrees (optional)
     * @param  float|null $brightness Brightness multiplier (1.0 &#x3D; no change) (optional)
     * @param  float|null $contrast Contrast multiplier (1.0 &#x3D; no change) (optional)
     * @param  float|null $blur Blur amount (0 &#x3D; none, higher &#x3D; more blur) (optional)
     * @param  float|null $noise Noise amount (0 &#x3D; none, higher &#x3D; more noise) (optional)
     * @param  bool|null $yellowish Simulate yellowed paper (optional)
     * @param  int|null $resolution Rendering resolution in DPI (optional)
     * @param  bool|null $advanced_enabled Whether advanced settings are enabled (optional)
     * @param  int|null $quality_value (optional)
     * @param  int|null $rotation_value (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scannerEffect'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function scannerEffectRequest($file_input, $quality, $rotation, $colorspace = null, $border = null, $rotate = null, $rotate_variance = null, $brightness = null, $contrast = null, $blur = null, $noise = null, $yellowish = null, $resolution = null, $advanced_enabled = null, $quality_value = null, $rotation_value = null, string $contentType = self::contentTypes['scannerEffect'][0])
    {

        // verify the required parameter 'file_input' is set
        if ($file_input === null || (is_array($file_input) && count($file_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_input when calling scannerEffect'
            );
        }

        // verify the required parameter 'quality' is set
        if ($quality === null || (is_array($quality) && count($quality) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $quality when calling scannerEffect'
            );
        }

        // verify the required parameter 'rotation' is set
        if ($rotation === null || (is_array($rotation) && count($rotation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rotation when calling scannerEffect'
            );
        }















        $resourcePath = '/api/v1/misc/scanner-effect';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'quality' => $quality,
            'rotation' => $rotation,
            'colorspace' => $colorspace,
            'border' => $border,
            'rotate' => $rotate,
            'rotate_variance' => $rotate_variance,
            'brightness' => $brightness,
            'contrast' => $contrast,
            'blur' => $blur,
            'noise' => $noise,
            'yellowish' => $yellowish,
            'resolution' => $resolution,
            'advanced_enabled' => $advanced_enabled,
            'quality_value' => $quality_value,
            'rotation_value' => $rotation_value,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unlockPDFForms
     *
     * Remove read-only property from form fields
     *
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockPDFForms'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function unlockPDFForms($file_input = null, $file_id = null, string $contentType = self::contentTypes['unlockPDFForms'][0])
    {
        list($response) = $this->unlockPDFFormsWithHttpInfo($file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation unlockPDFFormsWithHttpInfo
     *
     * Remove read-only property from form fields
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockPDFForms'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function unlockPDFFormsWithHttpInfo($file_input = null, $file_id = null, string $contentType = self::contentTypes['unlockPDFForms'][0])
    {
        $request = $this->unlockPDFFormsRequest($file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation unlockPDFFormsAsync
     *
     * Remove read-only property from form fields
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockPDFForms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unlockPDFFormsAsync($file_input = null, $file_id = null, string $contentType = self::contentTypes['unlockPDFForms'][0])
    {
        return $this->unlockPDFFormsAsyncWithHttpInfo($file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unlockPDFFormsAsyncWithHttpInfo
     *
     * Remove read-only property from form fields
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockPDFForms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unlockPDFFormsAsyncWithHttpInfo($file_input = null, $file_id = null, string $contentType = self::contentTypes['unlockPDFForms'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->unlockPDFFormsRequest($file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unlockPDFForms'
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockPDFForms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unlockPDFFormsRequest($file_input = null, $file_id = null, string $contentType = self::contentTypes['unlockPDFForms'][0])
    {




        $resourcePath = '/api/v1/misc/unlock-pdf-forms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
