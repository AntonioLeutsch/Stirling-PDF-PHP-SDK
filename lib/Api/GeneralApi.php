<?php
/**
 * GeneralApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Stirling PDF - Processing API
 *
 * API documentation for PDF processing operations including conversion, manipulation, security, and utilities. Please note all requests require authentication and as such should have a 'X-API-KEY' provided in their header
 *
 * The version of the OpenAPI document: 1.0.1
 * Contact: contact@stirlingpdf.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.19.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * GeneralApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class GeneralApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'autoSplitPdf1' => [
            'multipart/form-data',
        ],
        'createBookletImposition' => [
            'multipart/form-data',
        ],
        'cropPdf' => [
            'multipart/form-data',
        ],
        'deletePages' => [
            'multipart/form-data',
        ],
        'editTableOfContents' => [
            'multipart/form-data',
        ],
        'extractBookmarks' => [
            'multipart/form-data',
        ],
        'mergeMultiplePagesIntoOne' => [
            'multipart/form-data',
        ],
        'mergePdfs' => [
            'multipart/form-data',
        ],
        'overlayPdfs' => [
            'multipart/form-data',
        ],
        'pdfToSinglePage' => [
            'multipart/form-data',
        ],
        'rearrangePages' => [
            'multipart/form-data',
        ],
        'removeImages' => [
            'multipart/form-data',
        ],
        'rotatePDF' => [
            'multipart/form-data',
        ],
        'scalePages' => [
            'multipart/form-data',
        ],
        'splitPdf' => [
            'multipart/form-data',
        ],
        'splitPdf1' => [
            'multipart/form-data',
        ],
        'splitPdf2' => [
            'multipart/form-data',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation autoSplitPdf1
     *
     * Auto split PDF pages into separate documents based on size or count
     *
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  int|null $split_type Determines the type of split: 0 for size, 1 for page count, 2 for document count (optional, default to 0)
     * @param  string|null $split_value Value for split: size in MB (e.g., &#39;10MB&#39;) or number of pages (e.g., &#39;5&#39;) (optional, default to '10MB')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autoSplitPdf1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function autoSplitPdf1($file_input = null, $file_id = null, $split_type = 0, $split_value = '10MB', string $contentType = self::contentTypes['autoSplitPdf1'][0])
    {
        list($response) = $this->autoSplitPdf1WithHttpInfo($file_input, $file_id, $split_type, $split_value, $contentType);
        return $response;
    }

    /**
     * Operation autoSplitPdf1WithHttpInfo
     *
     * Auto split PDF pages into separate documents based on size or count
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  int|null $split_type Determines the type of split: 0 for size, 1 for page count, 2 for document count (optional, default to 0)
     * @param  string|null $split_value Value for split: size in MB (e.g., &#39;10MB&#39;) or number of pages (e.g., &#39;5&#39;) (optional, default to '10MB')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autoSplitPdf1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function autoSplitPdf1WithHttpInfo($file_input = null, $file_id = null, $split_type = 0, $split_value = '10MB', string $contentType = self::contentTypes['autoSplitPdf1'][0])
    {
        $request = $this->autoSplitPdf1Request($file_input, $file_id, $split_type, $split_value, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation autoSplitPdf1Async
     *
     * Auto split PDF pages into separate documents based on size or count
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  int|null $split_type Determines the type of split: 0 for size, 1 for page count, 2 for document count (optional, default to 0)
     * @param  string|null $split_value Value for split: size in MB (e.g., &#39;10MB&#39;) or number of pages (e.g., &#39;5&#39;) (optional, default to '10MB')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autoSplitPdf1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autoSplitPdf1Async($file_input = null, $file_id = null, $split_type = 0, $split_value = '10MB', string $contentType = self::contentTypes['autoSplitPdf1'][0])
    {
        return $this->autoSplitPdf1AsyncWithHttpInfo($file_input, $file_id, $split_type, $split_value, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation autoSplitPdf1AsyncWithHttpInfo
     *
     * Auto split PDF pages into separate documents based on size or count
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  int|null $split_type Determines the type of split: 0 for size, 1 for page count, 2 for document count (optional, default to 0)
     * @param  string|null $split_value Value for split: size in MB (e.g., &#39;10MB&#39;) or number of pages (e.g., &#39;5&#39;) (optional, default to '10MB')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autoSplitPdf1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autoSplitPdf1AsyncWithHttpInfo($file_input = null, $file_id = null, $split_type = 0, $split_value = '10MB', string $contentType = self::contentTypes['autoSplitPdf1'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->autoSplitPdf1Request($file_input, $file_id, $split_type, $split_value, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'autoSplitPdf1'
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  int|null $split_type Determines the type of split: 0 for size, 1 for page count, 2 for document count (optional, default to 0)
     * @param  string|null $split_value Value for split: size in MB (e.g., &#39;10MB&#39;) or number of pages (e.g., &#39;5&#39;) (optional, default to '10MB')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['autoSplitPdf1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function autoSplitPdf1Request($file_input = null, $file_id = null, $split_type = 0, $split_value = '10MB', string $contentType = self::contentTypes['autoSplitPdf1'][0])
    {






        $resourcePath = '/api/v1/general/split-by-size-or-count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'split_type' => $split_type,
            'split_value' => $split_value,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/zip', 'image/png', 'image/jpeg', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createBookletImposition
     *
     * Create a booklet with proper page imposition
     *
     * @param  string $booklet_type The booklet type to create. (required)
     * @param  int $pages_per_sheet The number of pages to fit onto a single sheet in the output PDF. (required)
     * @param  string $page_orientation The page orientation for the output booklet sheets. (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $add_border Boolean for if you wish to add border around the pages (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBookletImposition'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function createBookletImposition($booklet_type, $pages_per_sheet, $page_orientation, $file_input = null, $file_id = null, $add_border = null, string $contentType = self::contentTypes['createBookletImposition'][0])
    {
        list($response) = $this->createBookletImpositionWithHttpInfo($booklet_type, $pages_per_sheet, $page_orientation, $file_input, $file_id, $add_border, $contentType);
        return $response;
    }

    /**
     * Operation createBookletImpositionWithHttpInfo
     *
     * Create a booklet with proper page imposition
     *
     * @param  string $booklet_type The booklet type to create. (required)
     * @param  int $pages_per_sheet The number of pages to fit onto a single sheet in the output PDF. (required)
     * @param  string $page_orientation The page orientation for the output booklet sheets. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $add_border Boolean for if you wish to add border around the pages (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBookletImposition'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBookletImpositionWithHttpInfo($booklet_type, $pages_per_sheet, $page_orientation, $file_input = null, $file_id = null, $add_border = null, string $contentType = self::contentTypes['createBookletImposition'][0])
    {
        $request = $this->createBookletImpositionRequest($booklet_type, $pages_per_sheet, $page_orientation, $file_input, $file_id, $add_border, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createBookletImpositionAsync
     *
     * Create a booklet with proper page imposition
     *
     * @param  string $booklet_type The booklet type to create. (required)
     * @param  int $pages_per_sheet The number of pages to fit onto a single sheet in the output PDF. (required)
     * @param  string $page_orientation The page orientation for the output booklet sheets. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $add_border Boolean for if you wish to add border around the pages (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBookletImposition'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBookletImpositionAsync($booklet_type, $pages_per_sheet, $page_orientation, $file_input = null, $file_id = null, $add_border = null, string $contentType = self::contentTypes['createBookletImposition'][0])
    {
        return $this->createBookletImpositionAsyncWithHttpInfo($booklet_type, $pages_per_sheet, $page_orientation, $file_input, $file_id, $add_border, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createBookletImpositionAsyncWithHttpInfo
     *
     * Create a booklet with proper page imposition
     *
     * @param  string $booklet_type The booklet type to create. (required)
     * @param  int $pages_per_sheet The number of pages to fit onto a single sheet in the output PDF. (required)
     * @param  string $page_orientation The page orientation for the output booklet sheets. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $add_border Boolean for if you wish to add border around the pages (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBookletImposition'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBookletImpositionAsyncWithHttpInfo($booklet_type, $pages_per_sheet, $page_orientation, $file_input = null, $file_id = null, $add_border = null, string $contentType = self::contentTypes['createBookletImposition'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->createBookletImpositionRequest($booklet_type, $pages_per_sheet, $page_orientation, $file_input, $file_id, $add_border, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createBookletImposition'
     *
     * @param  string $booklet_type The booklet type to create. (required)
     * @param  int $pages_per_sheet The number of pages to fit onto a single sheet in the output PDF. (required)
     * @param  string $page_orientation The page orientation for the output booklet sheets. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $add_border Boolean for if you wish to add border around the pages (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBookletImposition'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createBookletImpositionRequest($booklet_type, $pages_per_sheet, $page_orientation, $file_input = null, $file_id = null, $add_border = null, string $contentType = self::contentTypes['createBookletImposition'][0])
    {

        // verify the required parameter 'booklet_type' is set
        if ($booklet_type === null || (is_array($booklet_type) && count($booklet_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $booklet_type when calling createBookletImposition'
            );
        }

        // verify the required parameter 'pages_per_sheet' is set
        if ($pages_per_sheet === null || (is_array($pages_per_sheet) && count($pages_per_sheet) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pages_per_sheet when calling createBookletImposition'
            );
        }

        // verify the required parameter 'page_orientation' is set
        if ($page_orientation === null || (is_array($page_orientation) && count($page_orientation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_orientation when calling createBookletImposition'
            );
        }





        $resourcePath = '/api/v1/general/booklet-imposition';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'booklet_type' => $booklet_type,
            'pages_per_sheet' => $pages_per_sheet,
            'add_border' => $add_border,
            'page_orientation' => $page_orientation,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cropPdf
     *
     * Crops a PDF document
     *
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  float|null $x The x-coordinate of the top-left corner of the crop area (optional)
     * @param  float|null $y The y-coordinate of the top-left corner of the crop area (optional)
     * @param  float|null $width The width of the crop area (optional)
     * @param  float|null $height The height of the crop area (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cropPdf'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function cropPdf($file_input = null, $file_id = null, $x = null, $y = null, $width = null, $height = null, string $contentType = self::contentTypes['cropPdf'][0])
    {
        list($response) = $this->cropPdfWithHttpInfo($file_input, $file_id, $x, $y, $width, $height, $contentType);
        return $response;
    }

    /**
     * Operation cropPdfWithHttpInfo
     *
     * Crops a PDF document
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  float|null $x The x-coordinate of the top-left corner of the crop area (optional)
     * @param  float|null $y The y-coordinate of the top-left corner of the crop area (optional)
     * @param  float|null $width The width of the crop area (optional)
     * @param  float|null $height The height of the crop area (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cropPdf'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function cropPdfWithHttpInfo($file_input = null, $file_id = null, $x = null, $y = null, $width = null, $height = null, string $contentType = self::contentTypes['cropPdf'][0])
    {
        $request = $this->cropPdfRequest($file_input, $file_id, $x, $y, $width, $height, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation cropPdfAsync
     *
     * Crops a PDF document
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  float|null $x The x-coordinate of the top-left corner of the crop area (optional)
     * @param  float|null $y The y-coordinate of the top-left corner of the crop area (optional)
     * @param  float|null $width The width of the crop area (optional)
     * @param  float|null $height The height of the crop area (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cropPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cropPdfAsync($file_input = null, $file_id = null, $x = null, $y = null, $width = null, $height = null, string $contentType = self::contentTypes['cropPdf'][0])
    {
        return $this->cropPdfAsyncWithHttpInfo($file_input, $file_id, $x, $y, $width, $height, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cropPdfAsyncWithHttpInfo
     *
     * Crops a PDF document
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  float|null $x The x-coordinate of the top-left corner of the crop area (optional)
     * @param  float|null $y The y-coordinate of the top-left corner of the crop area (optional)
     * @param  float|null $width The width of the crop area (optional)
     * @param  float|null $height The height of the crop area (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cropPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cropPdfAsyncWithHttpInfo($file_input = null, $file_id = null, $x = null, $y = null, $width = null, $height = null, string $contentType = self::contentTypes['cropPdf'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->cropPdfRequest($file_input, $file_id, $x, $y, $width, $height, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cropPdf'
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  float|null $x The x-coordinate of the top-left corner of the crop area (optional)
     * @param  float|null $y The y-coordinate of the top-left corner of the crop area (optional)
     * @param  float|null $width The width of the crop area (optional)
     * @param  float|null $height The height of the crop area (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cropPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cropPdfRequest($file_input = null, $file_id = null, $x = null, $y = null, $width = null, $height = null, string $contentType = self::contentTypes['cropPdf'][0])
    {








        $resourcePath = '/api/v1/general/crop';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'x' => $x,
            'y' => $y,
            'width' => $width,
            'height' => $height,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePages
     *
     * Remove pages from a PDF file
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePages'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function deletePages($page_numbers, $file_input = null, $file_id = null, string $contentType = self::contentTypes['deletePages'][0])
    {
        list($response) = $this->deletePagesWithHttpInfo($page_numbers, $file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation deletePagesWithHttpInfo
     *
     * Remove pages from a PDF file
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePages'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePagesWithHttpInfo($page_numbers, $file_input = null, $file_id = null, string $contentType = self::contentTypes['deletePages'][0])
    {
        $request = $this->deletePagesRequest($page_numbers, $file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deletePagesAsync
     *
     * Remove pages from a PDF file
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePagesAsync($page_numbers, $file_input = null, $file_id = null, string $contentType = self::contentTypes['deletePages'][0])
    {
        return $this->deletePagesAsyncWithHttpInfo($page_numbers, $file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePagesAsyncWithHttpInfo
     *
     * Remove pages from a PDF file
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePagesAsyncWithHttpInfo($page_numbers, $file_input = null, $file_id = null, string $contentType = self::contentTypes['deletePages'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->deletePagesRequest($page_numbers, $file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePages'
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deletePagesRequest($page_numbers, $file_input = null, $file_id = null, string $contentType = self::contentTypes['deletePages'][0])
    {

        // verify the required parameter 'page_numbers' is set
        if ($page_numbers === null || (is_array($page_numbers) && count($page_numbers) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_numbers when calling deletePages'
            );
        }




        $resourcePath = '/api/v1/general/remove-pages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'page_numbers' => $page_numbers,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editTableOfContents
     *
     * Edit Table of Contents
     *
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $bookmark_data Bookmark structure in JSON format (optional)
     * @param  bool|null $replace_existing Whether to replace existing bookmarks or append to them (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['editTableOfContents'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function editTableOfContents($file_input = null, $file_id = null, $bookmark_data = null, $replace_existing = null, string $contentType = self::contentTypes['editTableOfContents'][0])
    {
        list($response) = $this->editTableOfContentsWithHttpInfo($file_input, $file_id, $bookmark_data, $replace_existing, $contentType);
        return $response;
    }

    /**
     * Operation editTableOfContentsWithHttpInfo
     *
     * Edit Table of Contents
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $bookmark_data Bookmark structure in JSON format (optional)
     * @param  bool|null $replace_existing Whether to replace existing bookmarks or append to them (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['editTableOfContents'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function editTableOfContentsWithHttpInfo($file_input = null, $file_id = null, $bookmark_data = null, $replace_existing = null, string $contentType = self::contentTypes['editTableOfContents'][0])
    {
        $request = $this->editTableOfContentsRequest($file_input, $file_id, $bookmark_data, $replace_existing, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation editTableOfContentsAsync
     *
     * Edit Table of Contents
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $bookmark_data Bookmark structure in JSON format (optional)
     * @param  bool|null $replace_existing Whether to replace existing bookmarks or append to them (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['editTableOfContents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editTableOfContentsAsync($file_input = null, $file_id = null, $bookmark_data = null, $replace_existing = null, string $contentType = self::contentTypes['editTableOfContents'][0])
    {
        return $this->editTableOfContentsAsyncWithHttpInfo($file_input, $file_id, $bookmark_data, $replace_existing, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation editTableOfContentsAsyncWithHttpInfo
     *
     * Edit Table of Contents
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $bookmark_data Bookmark structure in JSON format (optional)
     * @param  bool|null $replace_existing Whether to replace existing bookmarks or append to them (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['editTableOfContents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function editTableOfContentsAsyncWithHttpInfo($file_input = null, $file_id = null, $bookmark_data = null, $replace_existing = null, string $contentType = self::contentTypes['editTableOfContents'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->editTableOfContentsRequest($file_input, $file_id, $bookmark_data, $replace_existing, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'editTableOfContents'
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $bookmark_data Bookmark structure in JSON format (optional)
     * @param  bool|null $replace_existing Whether to replace existing bookmarks or append to them (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['editTableOfContents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function editTableOfContentsRequest($file_input = null, $file_id = null, $bookmark_data = null, $replace_existing = null, string $contentType = self::contentTypes['editTableOfContents'][0])
    {






        $resourcePath = '/api/v1/general/edit-table-of-contents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'bookmark_data' => $bookmark_data,
            'replace_existing' => $replace_existing,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extractBookmarks
     *
     * Extract PDF Bookmarks
     *
     * @param  \SplFileObject $file file (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractBookmarks'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function extractBookmarks($file, string $contentType = self::contentTypes['extractBookmarks'][0])
    {
        list($response) = $this->extractBookmarksWithHttpInfo($file, $contentType);
        return $response;
    }

    /**
     * Operation extractBookmarksWithHttpInfo
     *
     * Extract PDF Bookmarks
     *
     * @param  \SplFileObject $file (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractBookmarks'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function extractBookmarksWithHttpInfo($file, string $contentType = self::contentTypes['extractBookmarks'][0])
    {
        $request = $this->extractBookmarksRequest($file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'object',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation extractBookmarksAsync
     *
     * Extract PDF Bookmarks
     *
     * @param  \SplFileObject $file (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractBookmarks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractBookmarksAsync($file, string $contentType = self::contentTypes['extractBookmarks'][0])
    {
        return $this->extractBookmarksAsyncWithHttpInfo($file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extractBookmarksAsyncWithHttpInfo
     *
     * Extract PDF Bookmarks
     *
     * @param  \SplFileObject $file (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractBookmarks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractBookmarksAsyncWithHttpInfo($file, string $contentType = self::contentTypes['extractBookmarks'][0])
    {
        $returnType = 'object';
        $request = $this->extractBookmarksRequest($file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extractBookmarks'
     *
     * @param  \SplFileObject $file (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['extractBookmarks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extractBookmarksRequest($file, string $contentType = self::contentTypes['extractBookmarks'][0])
    {

        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling extractBookmarks'
            );
        }


        $resourcePath = '/api/v1/general/extract-bookmarks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file' => $file,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mergeMultiplePagesIntoOne
     *
     * Merge multiple pages of a PDF document into a single page
     *
     * @param  int $pages_per_sheet The number of pages to fit onto a single sheet in the output PDF. (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $add_border Boolean for if you wish to add border around the pages (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergeMultiplePagesIntoOne'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function mergeMultiplePagesIntoOne($pages_per_sheet, $file_input = null, $file_id = null, $add_border = null, string $contentType = self::contentTypes['mergeMultiplePagesIntoOne'][0])
    {
        list($response) = $this->mergeMultiplePagesIntoOneWithHttpInfo($pages_per_sheet, $file_input, $file_id, $add_border, $contentType);
        return $response;
    }

    /**
     * Operation mergeMultiplePagesIntoOneWithHttpInfo
     *
     * Merge multiple pages of a PDF document into a single page
     *
     * @param  int $pages_per_sheet The number of pages to fit onto a single sheet in the output PDF. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $add_border Boolean for if you wish to add border around the pages (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergeMultiplePagesIntoOne'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function mergeMultiplePagesIntoOneWithHttpInfo($pages_per_sheet, $file_input = null, $file_id = null, $add_border = null, string $contentType = self::contentTypes['mergeMultiplePagesIntoOne'][0])
    {
        $request = $this->mergeMultiplePagesIntoOneRequest($pages_per_sheet, $file_input, $file_id, $add_border, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation mergeMultiplePagesIntoOneAsync
     *
     * Merge multiple pages of a PDF document into a single page
     *
     * @param  int $pages_per_sheet The number of pages to fit onto a single sheet in the output PDF. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $add_border Boolean for if you wish to add border around the pages (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergeMultiplePagesIntoOne'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mergeMultiplePagesIntoOneAsync($pages_per_sheet, $file_input = null, $file_id = null, $add_border = null, string $contentType = self::contentTypes['mergeMultiplePagesIntoOne'][0])
    {
        return $this->mergeMultiplePagesIntoOneAsyncWithHttpInfo($pages_per_sheet, $file_input, $file_id, $add_border, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mergeMultiplePagesIntoOneAsyncWithHttpInfo
     *
     * Merge multiple pages of a PDF document into a single page
     *
     * @param  int $pages_per_sheet The number of pages to fit onto a single sheet in the output PDF. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $add_border Boolean for if you wish to add border around the pages (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergeMultiplePagesIntoOne'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mergeMultiplePagesIntoOneAsyncWithHttpInfo($pages_per_sheet, $file_input = null, $file_id = null, $add_border = null, string $contentType = self::contentTypes['mergeMultiplePagesIntoOne'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->mergeMultiplePagesIntoOneRequest($pages_per_sheet, $file_input, $file_id, $add_border, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mergeMultiplePagesIntoOne'
     *
     * @param  int $pages_per_sheet The number of pages to fit onto a single sheet in the output PDF. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  bool|null $add_border Boolean for if you wish to add border around the pages (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergeMultiplePagesIntoOne'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function mergeMultiplePagesIntoOneRequest($pages_per_sheet, $file_input = null, $file_id = null, $add_border = null, string $contentType = self::contentTypes['mergeMultiplePagesIntoOne'][0])
    {

        // verify the required parameter 'pages_per_sheet' is set
        if ($pages_per_sheet === null || (is_array($pages_per_sheet) && count($pages_per_sheet) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pages_per_sheet when calling mergeMultiplePagesIntoOne'
            );
        }





        $resourcePath = '/api/v1/general/multi-page-layout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'pages_per_sheet' => $pages_per_sheet,
            'add_border' => $add_border,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mergePdfs
     *
     * Merge multiple PDF files into one
     *
     * @param  \SplFileObject[] $file_input The input PDF files (required)
     * @param  string $sort_type The type of sorting to be applied on the input files before merging. (required)
     * @param  bool $remove_cert_sign Flag indicating whether to remove certification signatures from the merged PDF. If true, all certification signatures will be removed from the final merged document. (required)
     * @param  bool|null $generate_toc Flag indicating whether to generate a table of contents for the merged PDF. If true, a table of contents will be created using the input filenames as chapter names. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergePdfs'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function mergePdfs($file_input, $sort_type, $remove_cert_sign, $generate_toc = false, string $contentType = self::contentTypes['mergePdfs'][0])
    {
        list($response) = $this->mergePdfsWithHttpInfo($file_input, $sort_type, $remove_cert_sign, $generate_toc, $contentType);
        return $response;
    }

    /**
     * Operation mergePdfsWithHttpInfo
     *
     * Merge multiple PDF files into one
     *
     * @param  \SplFileObject[] $file_input The input PDF files (required)
     * @param  string $sort_type The type of sorting to be applied on the input files before merging. (required)
     * @param  bool $remove_cert_sign Flag indicating whether to remove certification signatures from the merged PDF. If true, all certification signatures will be removed from the final merged document. (required)
     * @param  bool|null $generate_toc Flag indicating whether to generate a table of contents for the merged PDF. If true, a table of contents will be created using the input filenames as chapter names. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergePdfs'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function mergePdfsWithHttpInfo($file_input, $sort_type, $remove_cert_sign, $generate_toc = false, string $contentType = self::contentTypes['mergePdfs'][0])
    {
        $request = $this->mergePdfsRequest($file_input, $sort_type, $remove_cert_sign, $generate_toc, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation mergePdfsAsync
     *
     * Merge multiple PDF files into one
     *
     * @param  \SplFileObject[] $file_input The input PDF files (required)
     * @param  string $sort_type The type of sorting to be applied on the input files before merging. (required)
     * @param  bool $remove_cert_sign Flag indicating whether to remove certification signatures from the merged PDF. If true, all certification signatures will be removed from the final merged document. (required)
     * @param  bool|null $generate_toc Flag indicating whether to generate a table of contents for the merged PDF. If true, a table of contents will be created using the input filenames as chapter names. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergePdfs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mergePdfsAsync($file_input, $sort_type, $remove_cert_sign, $generate_toc = false, string $contentType = self::contentTypes['mergePdfs'][0])
    {
        return $this->mergePdfsAsyncWithHttpInfo($file_input, $sort_type, $remove_cert_sign, $generate_toc, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mergePdfsAsyncWithHttpInfo
     *
     * Merge multiple PDF files into one
     *
     * @param  \SplFileObject[] $file_input The input PDF files (required)
     * @param  string $sort_type The type of sorting to be applied on the input files before merging. (required)
     * @param  bool $remove_cert_sign Flag indicating whether to remove certification signatures from the merged PDF. If true, all certification signatures will be removed from the final merged document. (required)
     * @param  bool|null $generate_toc Flag indicating whether to generate a table of contents for the merged PDF. If true, a table of contents will be created using the input filenames as chapter names. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergePdfs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mergePdfsAsyncWithHttpInfo($file_input, $sort_type, $remove_cert_sign, $generate_toc = false, string $contentType = self::contentTypes['mergePdfs'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->mergePdfsRequest($file_input, $sort_type, $remove_cert_sign, $generate_toc, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mergePdfs'
     *
     * @param  \SplFileObject[] $file_input The input PDF files (required)
     * @param  string $sort_type The type of sorting to be applied on the input files before merging. (required)
     * @param  bool $remove_cert_sign Flag indicating whether to remove certification signatures from the merged PDF. If true, all certification signatures will be removed from the final merged document. (required)
     * @param  bool|null $generate_toc Flag indicating whether to generate a table of contents for the merged PDF. If true, a table of contents will be created using the input filenames as chapter names. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['mergePdfs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function mergePdfsRequest($file_input, $sort_type, $remove_cert_sign, $generate_toc = false, string $contentType = self::contentTypes['mergePdfs'][0])
    {

        // verify the required parameter 'file_input' is set
        if ($file_input === null || (is_array($file_input) && count($file_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_input when calling mergePdfs'
            );
        }

        // verify the required parameter 'sort_type' is set
        if ($sort_type === null || (is_array($sort_type) && count($sort_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sort_type when calling mergePdfs'
            );
        }

        // verify the required parameter 'remove_cert_sign' is set
        if ($remove_cert_sign === null || (is_array($remove_cert_sign) && count($remove_cert_sign) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $remove_cert_sign when calling mergePdfs'
            );
        }



        $resourcePath = '/api/v1/general/merge-pdfs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'sort_type' => $sort_type,
            'remove_cert_sign' => $remove_cert_sign,
            'generate_toc' => $generate_toc,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation overlayPdfs
     *
     * Overlay PDF files in various modes
     *
     * @param  \SplFileObject[] $overlay_files An array of PDF files to be used as overlays on the base PDF. The order in these files is applied based on the selected mode. (required)
     * @param  string $overlay_mode The mode of overlaying: &#39;SequentialOverlay&#39; for sequential application, &#39;InterleavedOverlay&#39; for round-robin application, &#39;FixedRepeatOverlay&#39; for fixed repetition based on provided counts (required)
     * @param  float $overlay_position Overlay position 0 is Foregound, 1 is Background (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  int[]|null $counts An array of integers specifying the number of times each corresponding overlay file should be applied in the &#39;FixedRepeatOverlay&#39; mode. This should match the length of the overlayFiles array. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['overlayPdfs'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function overlayPdfs($overlay_files, $overlay_mode, $overlay_position, $file_input = null, $file_id = null, $counts = null, string $contentType = self::contentTypes['overlayPdfs'][0])
    {
        list($response) = $this->overlayPdfsWithHttpInfo($overlay_files, $overlay_mode, $overlay_position, $file_input, $file_id, $counts, $contentType);
        return $response;
    }

    /**
     * Operation overlayPdfsWithHttpInfo
     *
     * Overlay PDF files in various modes
     *
     * @param  \SplFileObject[] $overlay_files An array of PDF files to be used as overlays on the base PDF. The order in these files is applied based on the selected mode. (required)
     * @param  string $overlay_mode The mode of overlaying: &#39;SequentialOverlay&#39; for sequential application, &#39;InterleavedOverlay&#39; for round-robin application, &#39;FixedRepeatOverlay&#39; for fixed repetition based on provided counts (required)
     * @param  float $overlay_position Overlay position 0 is Foregound, 1 is Background (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  int[]|null $counts An array of integers specifying the number of times each corresponding overlay file should be applied in the &#39;FixedRepeatOverlay&#39; mode. This should match the length of the overlayFiles array. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['overlayPdfs'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function overlayPdfsWithHttpInfo($overlay_files, $overlay_mode, $overlay_position, $file_input = null, $file_id = null, $counts = null, string $contentType = self::contentTypes['overlayPdfs'][0])
    {
        $request = $this->overlayPdfsRequest($overlay_files, $overlay_mode, $overlay_position, $file_input, $file_id, $counts, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation overlayPdfsAsync
     *
     * Overlay PDF files in various modes
     *
     * @param  \SplFileObject[] $overlay_files An array of PDF files to be used as overlays on the base PDF. The order in these files is applied based on the selected mode. (required)
     * @param  string $overlay_mode The mode of overlaying: &#39;SequentialOverlay&#39; for sequential application, &#39;InterleavedOverlay&#39; for round-robin application, &#39;FixedRepeatOverlay&#39; for fixed repetition based on provided counts (required)
     * @param  float $overlay_position Overlay position 0 is Foregound, 1 is Background (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  int[]|null $counts An array of integers specifying the number of times each corresponding overlay file should be applied in the &#39;FixedRepeatOverlay&#39; mode. This should match the length of the overlayFiles array. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['overlayPdfs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function overlayPdfsAsync($overlay_files, $overlay_mode, $overlay_position, $file_input = null, $file_id = null, $counts = null, string $contentType = self::contentTypes['overlayPdfs'][0])
    {
        return $this->overlayPdfsAsyncWithHttpInfo($overlay_files, $overlay_mode, $overlay_position, $file_input, $file_id, $counts, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation overlayPdfsAsyncWithHttpInfo
     *
     * Overlay PDF files in various modes
     *
     * @param  \SplFileObject[] $overlay_files An array of PDF files to be used as overlays on the base PDF. The order in these files is applied based on the selected mode. (required)
     * @param  string $overlay_mode The mode of overlaying: &#39;SequentialOverlay&#39; for sequential application, &#39;InterleavedOverlay&#39; for round-robin application, &#39;FixedRepeatOverlay&#39; for fixed repetition based on provided counts (required)
     * @param  float $overlay_position Overlay position 0 is Foregound, 1 is Background (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  int[]|null $counts An array of integers specifying the number of times each corresponding overlay file should be applied in the &#39;FixedRepeatOverlay&#39; mode. This should match the length of the overlayFiles array. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['overlayPdfs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function overlayPdfsAsyncWithHttpInfo($overlay_files, $overlay_mode, $overlay_position, $file_input = null, $file_id = null, $counts = null, string $contentType = self::contentTypes['overlayPdfs'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->overlayPdfsRequest($overlay_files, $overlay_mode, $overlay_position, $file_input, $file_id, $counts, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'overlayPdfs'
     *
     * @param  \SplFileObject[] $overlay_files An array of PDF files to be used as overlays on the base PDF. The order in these files is applied based on the selected mode. (required)
     * @param  string $overlay_mode The mode of overlaying: &#39;SequentialOverlay&#39; for sequential application, &#39;InterleavedOverlay&#39; for round-robin application, &#39;FixedRepeatOverlay&#39; for fixed repetition based on provided counts (required)
     * @param  float $overlay_position Overlay position 0 is Foregound, 1 is Background (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  int[]|null $counts An array of integers specifying the number of times each corresponding overlay file should be applied in the &#39;FixedRepeatOverlay&#39; mode. This should match the length of the overlayFiles array. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['overlayPdfs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function overlayPdfsRequest($overlay_files, $overlay_mode, $overlay_position, $file_input = null, $file_id = null, $counts = null, string $contentType = self::contentTypes['overlayPdfs'][0])
    {

        // verify the required parameter 'overlay_files' is set
        if ($overlay_files === null || (is_array($overlay_files) && count($overlay_files) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overlay_files when calling overlayPdfs'
            );
        }

        // verify the required parameter 'overlay_mode' is set
        if ($overlay_mode === null || (is_array($overlay_mode) && count($overlay_mode) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overlay_mode when calling overlayPdfs'
            );
        }

        // verify the required parameter 'overlay_position' is set
        if ($overlay_position === null || (is_array($overlay_position) && count($overlay_position) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overlay_position when calling overlayPdfs'
            );
        }





        $resourcePath = '/api/v1/general/overlay-pdfs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'overlay_files' => $overlay_files,
            'overlay_mode' => $overlay_mode,
            'counts' => $counts,
            'overlay_position' => $overlay_position,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfToSinglePage
     *
     * Convert a multi-page PDF into a single long page PDF
     *
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pdfToSinglePage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function pdfToSinglePage($file_input = null, $file_id = null, string $contentType = self::contentTypes['pdfToSinglePage'][0])
    {
        list($response) = $this->pdfToSinglePageWithHttpInfo($file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation pdfToSinglePageWithHttpInfo
     *
     * Convert a multi-page PDF into a single long page PDF
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pdfToSinglePage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfToSinglePageWithHttpInfo($file_input = null, $file_id = null, string $contentType = self::contentTypes['pdfToSinglePage'][0])
    {
        $request = $this->pdfToSinglePageRequest($file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation pdfToSinglePageAsync
     *
     * Convert a multi-page PDF into a single long page PDF
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pdfToSinglePage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfToSinglePageAsync($file_input = null, $file_id = null, string $contentType = self::contentTypes['pdfToSinglePage'][0])
    {
        return $this->pdfToSinglePageAsyncWithHttpInfo($file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfToSinglePageAsyncWithHttpInfo
     *
     * Convert a multi-page PDF into a single long page PDF
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pdfToSinglePage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfToSinglePageAsyncWithHttpInfo($file_input = null, $file_id = null, string $contentType = self::contentTypes['pdfToSinglePage'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->pdfToSinglePageRequest($file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfToSinglePage'
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pdfToSinglePage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function pdfToSinglePageRequest($file_input = null, $file_id = null, string $contentType = self::contentTypes['pdfToSinglePage'][0])
    {




        $resourcePath = '/api/v1/general/pdf-to-single-page';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rearrangePages
     *
     * Rearrange pages in a PDF file
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $custom_mode The custom mode for page rearrangement. Valid values are: CUSTOM: Uses order defined in PageNums DUPLICATE: Duplicate pages n times (if Page order defined as 4, then duplicates each page 4 times)REVERSE_ORDER: Reverses the order of all pages. DUPLEX_SORT: Sorts pages as if all fronts were scanned then all backs in reverse (1, n, 2, n-1, ...). BOOKLET_SORT: Arranges pages for booklet printing (last, first, second, second last, ...). ODD_EVEN_SPLIT: Splits and arranges pages into odd and even numbered pages. ODD_EVEN_MERGE: Merges pages and organises them alternately into odd and even pages. REMOVE_FIRST: Removes the first page. REMOVE_LAST: Removes the last page. REMOVE_FIRST_AND_LAST: Removes both the first and the last pages. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rearrangePages'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function rearrangePages($page_numbers, $file_input = null, $file_id = null, $custom_mode = null, string $contentType = self::contentTypes['rearrangePages'][0])
    {
        list($response) = $this->rearrangePagesWithHttpInfo($page_numbers, $file_input, $file_id, $custom_mode, $contentType);
        return $response;
    }

    /**
     * Operation rearrangePagesWithHttpInfo
     *
     * Rearrange pages in a PDF file
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $custom_mode The custom mode for page rearrangement. Valid values are: CUSTOM: Uses order defined in PageNums DUPLICATE: Duplicate pages n times (if Page order defined as 4, then duplicates each page 4 times)REVERSE_ORDER: Reverses the order of all pages. DUPLEX_SORT: Sorts pages as if all fronts were scanned then all backs in reverse (1, n, 2, n-1, ...). BOOKLET_SORT: Arranges pages for booklet printing (last, first, second, second last, ...). ODD_EVEN_SPLIT: Splits and arranges pages into odd and even numbered pages. ODD_EVEN_MERGE: Merges pages and organises them alternately into odd and even pages. REMOVE_FIRST: Removes the first page. REMOVE_LAST: Removes the last page. REMOVE_FIRST_AND_LAST: Removes both the first and the last pages. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rearrangePages'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function rearrangePagesWithHttpInfo($page_numbers, $file_input = null, $file_id = null, $custom_mode = null, string $contentType = self::contentTypes['rearrangePages'][0])
    {
        $request = $this->rearrangePagesRequest($page_numbers, $file_input, $file_id, $custom_mode, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation rearrangePagesAsync
     *
     * Rearrange pages in a PDF file
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $custom_mode The custom mode for page rearrangement. Valid values are: CUSTOM: Uses order defined in PageNums DUPLICATE: Duplicate pages n times (if Page order defined as 4, then duplicates each page 4 times)REVERSE_ORDER: Reverses the order of all pages. DUPLEX_SORT: Sorts pages as if all fronts were scanned then all backs in reverse (1, n, 2, n-1, ...). BOOKLET_SORT: Arranges pages for booklet printing (last, first, second, second last, ...). ODD_EVEN_SPLIT: Splits and arranges pages into odd and even numbered pages. ODD_EVEN_MERGE: Merges pages and organises them alternately into odd and even pages. REMOVE_FIRST: Removes the first page. REMOVE_LAST: Removes the last page. REMOVE_FIRST_AND_LAST: Removes both the first and the last pages. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rearrangePages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rearrangePagesAsync($page_numbers, $file_input = null, $file_id = null, $custom_mode = null, string $contentType = self::contentTypes['rearrangePages'][0])
    {
        return $this->rearrangePagesAsyncWithHttpInfo($page_numbers, $file_input, $file_id, $custom_mode, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rearrangePagesAsyncWithHttpInfo
     *
     * Rearrange pages in a PDF file
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $custom_mode The custom mode for page rearrangement. Valid values are: CUSTOM: Uses order defined in PageNums DUPLICATE: Duplicate pages n times (if Page order defined as 4, then duplicates each page 4 times)REVERSE_ORDER: Reverses the order of all pages. DUPLEX_SORT: Sorts pages as if all fronts were scanned then all backs in reverse (1, n, 2, n-1, ...). BOOKLET_SORT: Arranges pages for booklet printing (last, first, second, second last, ...). ODD_EVEN_SPLIT: Splits and arranges pages into odd and even numbered pages. ODD_EVEN_MERGE: Merges pages and organises them alternately into odd and even pages. REMOVE_FIRST: Removes the first page. REMOVE_LAST: Removes the last page. REMOVE_FIRST_AND_LAST: Removes both the first and the last pages. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rearrangePages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rearrangePagesAsyncWithHttpInfo($page_numbers, $file_input = null, $file_id = null, $custom_mode = null, string $contentType = self::contentTypes['rearrangePages'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->rearrangePagesRequest($page_numbers, $file_input, $file_id, $custom_mode, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rearrangePages'
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string|null $custom_mode The custom mode for page rearrangement. Valid values are: CUSTOM: Uses order defined in PageNums DUPLICATE: Duplicate pages n times (if Page order defined as 4, then duplicates each page 4 times)REVERSE_ORDER: Reverses the order of all pages. DUPLEX_SORT: Sorts pages as if all fronts were scanned then all backs in reverse (1, n, 2, n-1, ...). BOOKLET_SORT: Arranges pages for booklet printing (last, first, second, second last, ...). ODD_EVEN_SPLIT: Splits and arranges pages into odd and even numbered pages. ODD_EVEN_MERGE: Merges pages and organises them alternately into odd and even pages. REMOVE_FIRST: Removes the first page. REMOVE_LAST: Removes the last page. REMOVE_FIRST_AND_LAST: Removes both the first and the last pages. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rearrangePages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function rearrangePagesRequest($page_numbers, $file_input = null, $file_id = null, $custom_mode = null, string $contentType = self::contentTypes['rearrangePages'][0])
    {

        // verify the required parameter 'page_numbers' is set
        if ($page_numbers === null || (is_array($page_numbers) && count($page_numbers) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_numbers when calling rearrangePages'
            );
        }





        $resourcePath = '/api/v1/general/rearrange-pages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'page_numbers' => $page_numbers,
            'custom_mode' => $custom_mode,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeImages
     *
     * Remove images from file to reduce the file size.
     *
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeImages'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function removeImages($file_input = null, $file_id = null, string $contentType = self::contentTypes['removeImages'][0])
    {
        list($response) = $this->removeImagesWithHttpInfo($file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation removeImagesWithHttpInfo
     *
     * Remove images from file to reduce the file size.
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeImages'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeImagesWithHttpInfo($file_input = null, $file_id = null, string $contentType = self::contentTypes['removeImages'][0])
    {
        $request = $this->removeImagesRequest($file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation removeImagesAsync
     *
     * Remove images from file to reduce the file size.
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeImages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeImagesAsync($file_input = null, $file_id = null, string $contentType = self::contentTypes['removeImages'][0])
    {
        return $this->removeImagesAsyncWithHttpInfo($file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeImagesAsyncWithHttpInfo
     *
     * Remove images from file to reduce the file size.
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeImages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeImagesAsyncWithHttpInfo($file_input = null, $file_id = null, string $contentType = self::contentTypes['removeImages'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->removeImagesRequest($file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeImages'
     *
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeImages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function removeImagesRequest($file_input = null, $file_id = null, string $contentType = self::contentTypes['removeImages'][0])
    {




        $resourcePath = '/api/v1/general/remove-image-pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rotatePDF
     *
     * Rotate a PDF file
     *
     * @param  int $angle The angle by which to rotate the PDF file. This should be a multiple of 90. (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rotatePDF'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function rotatePDF($angle, $file_input = null, $file_id = null, string $contentType = self::contentTypes['rotatePDF'][0])
    {
        list($response) = $this->rotatePDFWithHttpInfo($angle, $file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation rotatePDFWithHttpInfo
     *
     * Rotate a PDF file
     *
     * @param  int $angle The angle by which to rotate the PDF file. This should be a multiple of 90. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rotatePDF'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function rotatePDFWithHttpInfo($angle, $file_input = null, $file_id = null, string $contentType = self::contentTypes['rotatePDF'][0])
    {
        $request = $this->rotatePDFRequest($angle, $file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation rotatePDFAsync
     *
     * Rotate a PDF file
     *
     * @param  int $angle The angle by which to rotate the PDF file. This should be a multiple of 90. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rotatePDF'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rotatePDFAsync($angle, $file_input = null, $file_id = null, string $contentType = self::contentTypes['rotatePDF'][0])
    {
        return $this->rotatePDFAsyncWithHttpInfo($angle, $file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rotatePDFAsyncWithHttpInfo
     *
     * Rotate a PDF file
     *
     * @param  int $angle The angle by which to rotate the PDF file. This should be a multiple of 90. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rotatePDF'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rotatePDFAsyncWithHttpInfo($angle, $file_input = null, $file_id = null, string $contentType = self::contentTypes['rotatePDF'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->rotatePDFRequest($angle, $file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rotatePDF'
     *
     * @param  int $angle The angle by which to rotate the PDF file. This should be a multiple of 90. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['rotatePDF'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function rotatePDFRequest($angle, $file_input = null, $file_id = null, string $contentType = self::contentTypes['rotatePDF'][0])
    {

        // verify the required parameter 'angle' is set
        if ($angle === null || (is_array($angle) && count($angle) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $angle when calling rotatePDF'
            );
        }




        $resourcePath = '/api/v1/general/rotate-pdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'angle' => $angle,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation scalePages
     *
     * Change the size of a PDF page/document
     *
     * @param  string $page_size The scale of pages in the output PDF. Acceptable values are A0-A6, LETTER, LEGAL, KEEP. (required)
     * @param  float $scale_factor The scale of the content on the pages of the output PDF. Acceptable values are floats. (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scalePages'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function scalePages($page_size, $scale_factor, $file_input = null, $file_id = null, string $contentType = self::contentTypes['scalePages'][0])
    {
        list($response) = $this->scalePagesWithHttpInfo($page_size, $scale_factor, $file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation scalePagesWithHttpInfo
     *
     * Change the size of a PDF page/document
     *
     * @param  string $page_size The scale of pages in the output PDF. Acceptable values are A0-A6, LETTER, LEGAL, KEEP. (required)
     * @param  float $scale_factor The scale of the content on the pages of the output PDF. Acceptable values are floats. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scalePages'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function scalePagesWithHttpInfo($page_size, $scale_factor, $file_input = null, $file_id = null, string $contentType = self::contentTypes['scalePages'][0])
    {
        $request = $this->scalePagesRequest($page_size, $scale_factor, $file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation scalePagesAsync
     *
     * Change the size of a PDF page/document
     *
     * @param  string $page_size The scale of pages in the output PDF. Acceptable values are A0-A6, LETTER, LEGAL, KEEP. (required)
     * @param  float $scale_factor The scale of the content on the pages of the output PDF. Acceptable values are floats. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scalePages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scalePagesAsync($page_size, $scale_factor, $file_input = null, $file_id = null, string $contentType = self::contentTypes['scalePages'][0])
    {
        return $this->scalePagesAsyncWithHttpInfo($page_size, $scale_factor, $file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scalePagesAsyncWithHttpInfo
     *
     * Change the size of a PDF page/document
     *
     * @param  string $page_size The scale of pages in the output PDF. Acceptable values are A0-A6, LETTER, LEGAL, KEEP. (required)
     * @param  float $scale_factor The scale of the content on the pages of the output PDF. Acceptable values are floats. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scalePages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scalePagesAsyncWithHttpInfo($page_size, $scale_factor, $file_input = null, $file_id = null, string $contentType = self::contentTypes['scalePages'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->scalePagesRequest($page_size, $scale_factor, $file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scalePages'
     *
     * @param  string $page_size The scale of pages in the output PDF. Acceptable values are A0-A6, LETTER, LEGAL, KEEP. (required)
     * @param  float $scale_factor The scale of the content on the pages of the output PDF. Acceptable values are floats. (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scalePages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function scalePagesRequest($page_size, $scale_factor, $file_input = null, $file_id = null, string $contentType = self::contentTypes['scalePages'][0])
    {

        // verify the required parameter 'page_size' is set
        if ($page_size === null || (is_array($page_size) && count($page_size) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_size when calling scalePages'
            );
        }

        // verify the required parameter 'scale_factor' is set
        if ($scale_factor === null || (is_array($scale_factor) && count($scale_factor) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scale_factor when calling scalePages'
            );
        }
        if ($scale_factor < 0) {
            throw new \InvalidArgumentException('invalid value for "$scale_factor" when calling GeneralApi.scalePages, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/api/v1/general/scale-pages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'page_size' => $page_size,
            'scale_factor' => $scale_factor,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation splitPdf
     *
     * Split PDF pages into smaller sections
     *
     * @param  int $horizontal_divisions Number of horizontal divisions for each PDF page (required)
     * @param  int $vertical_divisions Number of vertical divisions for each PDF page (required)
     * @param  bool $merge Merge the split documents into a single PDF (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['splitPdf'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function splitPdf($horizontal_divisions, $vertical_divisions, $merge, $file_input = null, $file_id = null, string $contentType = self::contentTypes['splitPdf'][0])
    {
        list($response) = $this->splitPdfWithHttpInfo($horizontal_divisions, $vertical_divisions, $merge, $file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation splitPdfWithHttpInfo
     *
     * Split PDF pages into smaller sections
     *
     * @param  int $horizontal_divisions Number of horizontal divisions for each PDF page (required)
     * @param  int $vertical_divisions Number of vertical divisions for each PDF page (required)
     * @param  bool $merge Merge the split documents into a single PDF (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['splitPdf'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function splitPdfWithHttpInfo($horizontal_divisions, $vertical_divisions, $merge, $file_input = null, $file_id = null, string $contentType = self::contentTypes['splitPdf'][0])
    {
        $request = $this->splitPdfRequest($horizontal_divisions, $vertical_divisions, $merge, $file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation splitPdfAsync
     *
     * Split PDF pages into smaller sections
     *
     * @param  int $horizontal_divisions Number of horizontal divisions for each PDF page (required)
     * @param  int $vertical_divisions Number of vertical divisions for each PDF page (required)
     * @param  bool $merge Merge the split documents into a single PDF (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['splitPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function splitPdfAsync($horizontal_divisions, $vertical_divisions, $merge, $file_input = null, $file_id = null, string $contentType = self::contentTypes['splitPdf'][0])
    {
        return $this->splitPdfAsyncWithHttpInfo($horizontal_divisions, $vertical_divisions, $merge, $file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation splitPdfAsyncWithHttpInfo
     *
     * Split PDF pages into smaller sections
     *
     * @param  int $horizontal_divisions Number of horizontal divisions for each PDF page (required)
     * @param  int $vertical_divisions Number of vertical divisions for each PDF page (required)
     * @param  bool $merge Merge the split documents into a single PDF (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['splitPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function splitPdfAsyncWithHttpInfo($horizontal_divisions, $vertical_divisions, $merge, $file_input = null, $file_id = null, string $contentType = self::contentTypes['splitPdf'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->splitPdfRequest($horizontal_divisions, $vertical_divisions, $merge, $file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'splitPdf'
     *
     * @param  int $horizontal_divisions Number of horizontal divisions for each PDF page (required)
     * @param  int $vertical_divisions Number of vertical divisions for each PDF page (required)
     * @param  bool $merge Merge the split documents into a single PDF (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['splitPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function splitPdfRequest($horizontal_divisions, $vertical_divisions, $merge, $file_input = null, $file_id = null, string $contentType = self::contentTypes['splitPdf'][0])
    {

        // verify the required parameter 'horizontal_divisions' is set
        if ($horizontal_divisions === null || (is_array($horizontal_divisions) && count($horizontal_divisions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $horizontal_divisions when calling splitPdf'
            );
        }
        if ($horizontal_divisions < 0) {
            throw new \InvalidArgumentException('invalid value for "$horizontal_divisions" when calling GeneralApi.splitPdf, must be bigger than or equal to 0.');
        }
        
        // verify the required parameter 'vertical_divisions' is set
        if ($vertical_divisions === null || (is_array($vertical_divisions) && count($vertical_divisions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vertical_divisions when calling splitPdf'
            );
        }
        if ($vertical_divisions < 0) {
            throw new \InvalidArgumentException('invalid value for "$vertical_divisions" when calling GeneralApi.splitPdf, must be bigger than or equal to 0.');
        }
        
        // verify the required parameter 'merge' is set
        if ($merge === null || (is_array($merge) && count($merge) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merge when calling splitPdf'
            );
        }




        $resourcePath = '/api/v1/general/split-pdf-by-sections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'horizontal_divisions' => $horizontal_divisions,
            'vertical_divisions' => $vertical_divisions,
            'merge' => $merge,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/zip', 'image/png', 'image/jpeg', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation splitPdf1
     *
     * Split PDFs by Chapters
     *
     * @param  bool $include_metadata Whether to include Metadata or not (required)
     * @param  bool $allow_duplicates Whether to allow duplicates or not (required)
     * @param  int $bookmark_level Maximum bookmark level required (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['splitPdf1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function splitPdf1($include_metadata, $allow_duplicates, $bookmark_level, $file_input = null, $file_id = null, string $contentType = self::contentTypes['splitPdf1'][0])
    {
        list($response) = $this->splitPdf1WithHttpInfo($include_metadata, $allow_duplicates, $bookmark_level, $file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation splitPdf1WithHttpInfo
     *
     * Split PDFs by Chapters
     *
     * @param  bool $include_metadata Whether to include Metadata or not (required)
     * @param  bool $allow_duplicates Whether to allow duplicates or not (required)
     * @param  int $bookmark_level Maximum bookmark level required (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['splitPdf1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function splitPdf1WithHttpInfo($include_metadata, $allow_duplicates, $bookmark_level, $file_input = null, $file_id = null, string $contentType = self::contentTypes['splitPdf1'][0])
    {
        $request = $this->splitPdf1Request($include_metadata, $allow_duplicates, $bookmark_level, $file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation splitPdf1Async
     *
     * Split PDFs by Chapters
     *
     * @param  bool $include_metadata Whether to include Metadata or not (required)
     * @param  bool $allow_duplicates Whether to allow duplicates or not (required)
     * @param  int $bookmark_level Maximum bookmark level required (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['splitPdf1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function splitPdf1Async($include_metadata, $allow_duplicates, $bookmark_level, $file_input = null, $file_id = null, string $contentType = self::contentTypes['splitPdf1'][0])
    {
        return $this->splitPdf1AsyncWithHttpInfo($include_metadata, $allow_duplicates, $bookmark_level, $file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation splitPdf1AsyncWithHttpInfo
     *
     * Split PDFs by Chapters
     *
     * @param  bool $include_metadata Whether to include Metadata or not (required)
     * @param  bool $allow_duplicates Whether to allow duplicates or not (required)
     * @param  int $bookmark_level Maximum bookmark level required (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['splitPdf1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function splitPdf1AsyncWithHttpInfo($include_metadata, $allow_duplicates, $bookmark_level, $file_input = null, $file_id = null, string $contentType = self::contentTypes['splitPdf1'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->splitPdf1Request($include_metadata, $allow_duplicates, $bookmark_level, $file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'splitPdf1'
     *
     * @param  bool $include_metadata Whether to include Metadata or not (required)
     * @param  bool $allow_duplicates Whether to allow duplicates or not (required)
     * @param  int $bookmark_level Maximum bookmark level required (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['splitPdf1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function splitPdf1Request($include_metadata, $allow_duplicates, $bookmark_level, $file_input = null, $file_id = null, string $contentType = self::contentTypes['splitPdf1'][0])
    {

        // verify the required parameter 'include_metadata' is set
        if ($include_metadata === null || (is_array($include_metadata) && count($include_metadata) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $include_metadata when calling splitPdf1'
            );
        }

        // verify the required parameter 'allow_duplicates' is set
        if ($allow_duplicates === null || (is_array($allow_duplicates) && count($allow_duplicates) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $allow_duplicates when calling splitPdf1'
            );
        }

        // verify the required parameter 'bookmark_level' is set
        if ($bookmark_level === null || (is_array($bookmark_level) && count($bookmark_level) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bookmark_level when calling splitPdf1'
            );
        }
        if ($bookmark_level < 0) {
            throw new \InvalidArgumentException('invalid value for "$bookmark_level" when calling GeneralApi.splitPdf1, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/api/v1/general/split-pdf-by-chapters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'include_metadata' => $include_metadata,
            'allow_duplicates' => $allow_duplicates,
            'bookmark_level' => $bookmark_level,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/zip', 'image/png', 'image/jpeg', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation splitPdf2
     *
     * Split a PDF file into separate documents
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  \SplFileObject|null $file_input file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['splitPdf2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response
     */
    public function splitPdf2($page_numbers, $file_input = null, $file_id = null, string $contentType = self::contentTypes['splitPdf2'][0])
    {
        list($response) = $this->splitPdf2WithHttpInfo($page_numbers, $file_input, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation splitPdf2WithHttpInfo
     *
     * Split a PDF file into separate documents
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['splitPdf2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ValidateSignature400Response|\OpenAPI\Client\Model\ValidateSignature413Response|\OpenAPI\Client\Model\ValidateSignature422Response|\OpenAPI\Client\Model\ValidateSignature500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function splitPdf2WithHttpInfo($page_numbers, $file_input = null, $file_id = null, string $contentType = self::contentTypes['splitPdf2'][0])
    {
        $request = $this->splitPdf2Request($page_numbers, $file_input, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ValidateSignature500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation splitPdf2Async
     *
     * Split a PDF file into separate documents
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['splitPdf2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function splitPdf2Async($page_numbers, $file_input = null, $file_id = null, string $contentType = self::contentTypes['splitPdf2'][0])
    {
        return $this->splitPdf2AsyncWithHttpInfo($page_numbers, $file_input, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation splitPdf2AsyncWithHttpInfo
     *
     * Split a PDF file into separate documents
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['splitPdf2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function splitPdf2AsyncWithHttpInfo($page_numbers, $file_input = null, $file_id = null, string $contentType = self::contentTypes['splitPdf2'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->splitPdf2Request($page_numbers, $file_input, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'splitPdf2'
     *
     * @param  string $page_numbers The pages to select, Supports ranges (e.g., &#39;1,3,5-9&#39;), or &#39;all&#39; or functions in the format &#39;an+b&#39; where &#39;a&#39; is the multiplier of the page number &#39;n&#39;, and &#39;b&#39; is a constant (e.g., &#39;2n+1&#39;, &#39;3n&#39;, &#39;6n-5&#39;) (required)
     * @param  \SplFileObject|null $file_input (optional)
     * @param  string|null $file_id File ID for server-side files (can be used instead of fileInput) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['splitPdf2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function splitPdf2Request($page_numbers, $file_input = null, $file_id = null, string $contentType = self::contentTypes['splitPdf2'][0])
    {

        // verify the required parameter 'page_numbers' is set
        if ($page_numbers === null || (is_array($page_numbers) && count($page_numbers) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_numbers when calling splitPdf2'
            );
        }




        $resourcePath = '/api/v1/general/split-pages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_input' => $file_input,
            'file_id' => $file_id,
            'page_numbers' => $page_numbers,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'application/zip', 'image/png', 'image/jpeg', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
